{"posts":[{"title":"Redis入门","content":"Redis入门 简介 REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。 Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型 Redis 的配置文件位于 Redis 安装目录下，文件名为 redis.conf Redis操作库命令 命令 描述 select 下标[0~15] 切换对于库 dbsize 当前库以存储大小 flushdb 删除当前库中所有数据 flushall 删除全部库数据 Redis keys 常用命令 命令 描述 del key key 存在时删除key dump key 序列化给定key，并返回被序列化的值 exists key 检查key是否存在 expire key 5 设置key 5秒过期 keys pattern 查找所有符合pattern条件的key ttl key 检查key过期时间剩余时间 Redis String 常用命令 命令 描述 set key value 设置key的值为value setrang key 偏移量 value 用value值覆写给定key所储存的字符串值，从偏移量开始 strlen key 返回key字符串长度 setex key 5 value 将值value关联到key，并将key的过期时间设为5秒 setex key value key的值不存在就设置value值 get key 获取key的值 getrange key 0 1 获取key的第一位值 getset key value 将给定key的值设为value，并返回key的旧值 mset key1 value1 key2 value2 同时设置一个或多个key-value对 incr key 将key中的数字 ++ incrby key 10 将key中的数字 +=10 decr key 将key中的数字 -- decrby key 10 将key中的数字 -=10 append key newValue 给存在的key并且值是字符串就在最后最加newValue Redis Hash 常用命令 命令 描述 hset key field value 设置哈希表key字段field的值为value hsetnx key field value 哈希表key字段不存在时，设置field的值为value hmsetnx key field1 value1 field2 value2 设置哈希表key字段field1的值为value1,field2 value2的值 hget key field 获取哈希表中key field的值 hgetall key 获取哈希表中key所有字段和值 hkeys key 获取所有哈希表中key所有字段 hvals key 获取所有哈希表中key所有值 hexists key field 查看哈希表中key field字段是否存在 hdel key field1 field2 删除一个或者多个哈希表字段 Redis List 常用命令 命令 描述 lpush key value1 value2 添加value1 value2到列表头部 lpushx key value 添加value添加到key的列表头部 rpush key value1 value2 添加value1 value2到key的列表中 rpushx key value 为存在的key添加value值 lset key 0 value 通过索引设置值(设置key的第一个字段的值为value) lindex key 0 获取key中第一个元素 lrange key 0 1 获取key中前两个元素 lpop key 移除并获取key列表的第一元素 rpop key 移除并获取key列表的最后一个元素 lrem key 移除并获取key列表的第一元素 llen key 获取key列表长度 Redis Set 常用命令 命令 描述 sadd key value1 value2 向集合内增加value1 value2 scard key 获取集合的成员数 sdiff key key2 返回第一个集合和其它集合的差异 sdiffstore destination key1 key2 返回key1 key2集合的差异并且存储在destination集合里面 sinter key1 key2 返回key1 key2集合交集 sunion key1 key2 返回key1 key2集合的并集 sinterstore destination key1 key2 返回key1 key2集合的交集并且存储在destination集合里面 sunionstore destination key1 key2 返回key1 key2集合的并集并且存储在destination集合里面 sismember key value 判断value是否在集合key的成员中 smember key 返回key集合中所有成员 smove key1 key2 value 将value元素从key1集合中移动到key2集合中 spop key 移除key并返回集合中的一个随机元素 srandmember key [count] 移除并返回key集合中一个或者多个成员 srem key [count] 移除key集合中一个或者多个成员 Redis Sorted Set 常用命令 命令 描述 zadd key 1 value 向有序集合key中添加value 排序分数是1 zcard key 获取有序集合的成员数 zcount key min max 计算有序集合中指定分区的成员数 zincrby key 10 value 为有序集合key中value成员排序分数增加10 zlexcount key min max 在有序集合key中计算区间内的成员数量 zrangee key start stop withscores 通过索引区间返回有序集合指定区间内的成员 zrangeebylex key start stop 通过字典区间返回有序集合的成员 zrank key value 返回有序集合中指定成员的索引 zrem key value 移除有序集合中的一个或多个成员 zremrangebylex key min max 移除有序集合中给定的字典区间的所有成员 zremrangebyrank key start stop 移除有序集合中给定的排名区间的所有成员 zremrangebyscore key min max 移除有序集合中给定的分数区间的所有成员 zrevrange key start stop withscores 返回有序集中指定区间内的成员，通过索引，分数从高到低 zrevrangebyscore key max min withscores 返回有序集中指定分数区间内的成员，分数从高到低排序 zrevrank key value 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序 zscore key value 返回有序集中，成员的分数值 ","link":"https://xiaoai7904.github.io/post/redis-ru-men/"},{"title":"Java动态代理机制","content":"Java动态代理机制 在先说动态代理之前，先看看什么是代理 代理 什么代理？给某一个对象提供一个代理，并由代理对象来控制对真实对象的访问，例如： 对象A提供了一个接口，但是这个接口只能通过对象B进行调用,如果其他对象需要调用必须通过对象B来调用对象A提供的接口,这样就可以称对象B为代理对象 有一个生产汽车的工厂,如果普通人要去购买汽车,必须通过4s店去购买，这里的4s店就是代理 简单理解了什么是代理之后，通过程序代码来模拟代理 我们还是以购买汽车为例 Tips：以下示例只是部分代码片段,不是完整代码 汽车工厂类 // 汽车工厂接口 public interface CarFactoryService { public Integer getPrice(); public void setPrice(int price); public void sell(String carName); } // 汽车工厂实现类 public class CarFactoryImpl implements CarFactoryService { // 汽车价格(单位: 万) private Integer carPrice = 100; @Override public Integer getPrice() { return carPrice; } @Override public void setPrice(int price) { carPrice += price; } @Override public void sell(String carName) { System.out.println(&quot;4s店购买了&quot; + carName + &quot;汽车,价格是&quot; + carPrice); }} 4S店 public class Shop4s implements CarFactoryService { private Integer carPrice = 20; @Override public void sell(String carName) { CarFactoryService carFactory; carFactory = new CarFactoryImpl(); carFactory.sell(carName); setPrice(carFactory.getPrice()); System.out.println(&quot;消费者购买了&quot; + carName + &quot;汽车,价格是&quot; + carPrice); } @Override public Integer getPrice() { return carPrice; } @Override public void setPrice(int price) { carPrice += price; }} 普通消费者 public class NormalConsumer { public void sell(String carName) { CarFactoryService shop4s = new Shop4s(); shop4s.sell(carName); } } 测试方法 public class TestApp { public static void main(String[] args) { NormalConsumer xiaoai = new NormalConsumer(); xiaoai.sell(&quot;奥迪A7&quot;); } 上面示例代码中实现简单代理方式,其中4S店就是代理对象, 在Java中我们称上面这种代理为静态代理 静态代理 使用静态代理我们可以在不修改源代码的情况，对功能进行增强,但是使用静态代理也有一定缺点,例如我们如果需要对工厂进行增加新功能,就需要在源代码和代理对象代码中新增逻辑 总结: 优点 实现简单,易理解 保护实际对象的业务逻辑对外暴露，从而提高安全性 缺点 代理对象和目标对象要实现统一的接口，新增功能会增加很多过多的代理类 不易维护,如果新增功能,代理类和目标类都需要新增代码 结合上面的优缺点这时候就出现了新的解决方案动态代理 动态代理 动态代理相比静态代理主要特点是，静态代理是在编译完成时已经产生Class文件，然而动态代理是在运行时动态生成类字节码，并加载到JVM中 Tips: 动态代理不需要实现接口，但是要求目标对象必须实现接口 在Java中有目前以下动态代理方式: JDK动态代理 --&gt; 根据接口创建代理对象 CGLIB动态代理 --&gt; 使用继承实现 JDK动态代理 JDK动代理主要使用了Java中的反射机制，JDK动态代理使用了java.lang.reflect.Proxy和java.lang.reflect.InvocationHandler两个类来实现 我们还是以购买汽车为例，通过动态代理改造上面静态代理方式的代码 示例代码： 汽车工厂类 // 汽车工厂接口 public interface CarFactoryService { public Integer getPrice(); public void setPrice(int price); public void sell(String carName); } // 汽车工厂实现类 public class CarFactoryImpl implements CarFactoryService { // 汽车价格(单位: 万) private Integer carPrice = 100; @Override public Integer getPrice() { return carPrice; } @Override public void setPrice(int price) { carPrice += price; } @Override public void sell(String carName) { System.out.println(&quot;4s店购买了&quot; + carName + &quot;汽车,价格是&quot; + carPrice); } } 代理处理类 public class MyHandler implements InvocationHandler { private Object target = null; public MyHandler1(Object target) { // 传入目标对象方法 this.target = target; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 1.可以对调用目标方法之前进行处理 System.out.println(&quot;消费者购买&quot; + args[0] + &quot;汽车,价格是汽车店基础上涨20万&quot;); // 2. 调用目标方法 // target: 目标对象方法， arg: 调用目标方法参数 return 当前方法执行结果 Object res = method.invoke(target, args); // 3.可以对调用完目标方法进行增强处理 System.out.println(&quot;消费者购买了&quot; + args[0] + &quot;汽车,价格是&quot; + 120); return res; }} 测试方法 public class TestApp { public static void main(String[] args) { CarFactoryService proxyTarget = new CarFactoryImpl(); CarFactoryService proxy = (CarFactoryService)Proxy.newProxyInstance(proxyTarget.getClass().getClassLoader(), proxyTarget.getClass().getInterfaces(), new MyHandler(proxyTarget)); proxy.sell(&quot;奥迪A7&quot;) } CGLIB动态代理 是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB通过继承方式实现代理 基于cglib动态代理去实现购车代码: 汽车工厂类 // 汽车工厂实现类 public class CarFactoryImpl { // 汽车价格(单位: 万) private Integer carPrice = 100; public Integer getPrice() { return carPrice; } public void setPrice(int price) { carPrice += price; } public void sell(String carName) { System.out.println(&quot;4s店购买了&quot; + carName + &quot;汽车,价格是&quot; + carPrice); } } 代理处理类 public class MyMethodInterceptor implements MethodInterceptor { @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { System.out.println(&quot;消费者购买&quot; + args[0] + &quot;汽车,价格是汽车店基础上涨20万&quot;); Object object = methodProxy.invokeSuper(o, objects); System.out.println(&quot;消费者购买了&quot; + args[0] + &quot;汽车,价格是&quot; + 120); return object; } } 测试方法 public class TestApp { public static void main(String[] args) { Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(CglibService.class); // 设置enhancer的回调对象 enhancer.setCallback(new MyMethodInterceptor()); // 创建代理对象 CglibService proxy= (CglibService)enhancer.create(); // 通过代理对象调用目标方法 proxy.sell(&quot;奥迪A7&quot;) } } ","link":"https://xiaoai7904.github.io/post/java-dong-tai-dai-li-ji-zhi/"},{"title":"MySql常用命令和介绍","content":" 创建数据表 # create tabele 表名(字段1 数据类型, 字段2 数据类型, ...); create tabele user(id VARCHAR(100), name VARCHAR(100), age INT); # 创建临时表 临时表只在当前连接可见，当关闭连接时会自动删除 create TEMPORARY table userTemp(id VARCHAR(100), name VARCHAR(100), age INT) id name age null null null 删除数据表 # drop tabele 表名; drop tabele user; 插入数据 # insert into 表名(字段1， 字段2) values(字段1值，字段2值，...) insert into user(id, name, age) values('1', 'xiaoai', 27) id name age 1 xiaoai 27 查询数据 # select * from 表名 select * from user id name age 1 xiaoai 27 where语句 # select * from 表名 where 判断条件 select * from user where age=27 select * from user where age&gt;=27 select * from user where age&lt;=27 select * from user where age is null select * from user where age is not null select * from user where age in(27,29) select * from user where age not in(27,29) select * from user where age REGEXP '^\\d+' update语句 # update 表名 set 字段1=字段值 update user set age=28 id name age 1 xiaoai 28 delete语句 # delete from 表名 where 条件 delete from user where id='1' id name age like语句（模糊查询） # select * from 表名 like 字段='值%' select * from user like name='xiao%' id name age 1 xiaoai 28 union(连接两个表查询结果) # tips: user1表暂时使用user表的数据 # select * from 表名1 union (ALL | DISTINCT) select * from 表名2 # ALL: 全部数据可以出现重复数据 # DISTINCT: 全部数据并且删除重复数据 select * from user union ALL select * from user1 id name age 1 xiaoai 28 1 xiaoai 28 order by语句(排序) 原始表数据: id name age 1 xiaoai 22 2 xiaoai1 23 3 xiaoai2 24 4 xiaoai3 25 5 xiaoai4 26 # ASC 升序 默认 # DESC 降序 # select * from 表名1 order by 字段名 排序值[ASC|DESC] select * from user order by age DESC id name age 5 xiaoai4 26 4 xiaoai3 25 3 xiaoai2 24 2 xiaoai1 23 1 xiaoai 22 group by(分组查询) 原始表数据: id name age 1 xiaoai 22 2 xiaoai1 22 3 xiaoai2 25 4 xiaoai3 25 5 xiaoai4 26 # select 分组字段, count(*) from 表名 group by 分组字段 select age, count(*) from user group by age age count(*) 22 2 25 2 26 1 外连接(inner join, left join, right join) 原始表数据 user: id name age 1 xiaoai 22 2 xiaoai1 22 原始表数据 subject: id subject name 1 java xiaoai 2 javascript xiaoai 3 nodeJs xiaoai2 # inner join 连接两个表格数据 # select 字段名,字段名 from 表名1 as 表名1别名 inner join select 字段名, 字段名 from 表名2 as 表名2别名 on 表名1别名.字段名=表名2别名.字段名 select u.name, u.age from user as u inner join select s.subject from subject as s on a.name=s.name u.name u.age s.subject xiaoai 22 java xiaoai 22 javascript # left join 连接两个表格,左边数据表的全部数据，即便右边表无对应数据 # select 字段名,字段名 from 表名1 as 表名1别名 left join select 字段名, 字段名 from 表名2 as 表名2别名 on 表名1别名.字段名=表名2别名.字段名 select u.name, u.age from user as u left join select s.subject from subject as s on a.name=s.name u.name u.age s.subject xiaoai 22 java xiaoai 22 javascript xiaoai1 22 null # right join 连接两个表格,右边数据表的全部数据，即便左边表无对应数据 # select 字段名,字段名 from 表名1 as 表名1别名 right join select 字段名, 字段名 from 表名2 as 表名2别名 on 表名1别名.字段名=表名2别名.字段名 select u.name, u.age from user as u right join select s.subject from subject as s on a.name=s.name u.name u.age s.subject xiaoai 22 java xiaoai 22 javascript null null nodeJs alter(修改数据表名或者修改数据表字段) 原始表数据 user: id name age 1 xiaoai 22 alter table user add adss varchar(100) # 添加字段 alter table user modify adss char # 修改表字段 alter table user alter adss set default 'xxxx省xxx市' alter table user drop adss # 删除表字段 limit语句 原始表数据 user: id name age 1 xiaoai 22 2 xiaoai1 23 3 xiaoai2 24 select * from user limit 0,1 id name age 1 xiaoai 22 索引 create index id_index on user(id) # 创建索引 alter table user add index id_index(id) # 修改表结构添加索引 show index from user # 显示索引 drop index id_index on user # 删除索引 导出sql select * from user into outfile './user.txt' # 导出user表数据到user.txt ","link":"https://xiaoai7904.github.io/post/mysql-chang-yong-ming-ling-he-jie-shao/"},{"title":" 随笔","content":"最近在学习新的编程语言Java,为什么要去学习呢？总结几点： 培养编程兴趣 不要为工作而编程,要觉得编程就是一个兴趣爱好,人对自己的兴趣爱在任何时候都不会去排斥 提高自己的学习技巧 通过学习新的东西,可以从中提高自己的学习技巧和学习方式 通过学习要培养自己的写作能力和表达能力 提升自己的知识广度 通过了解多个编程语言可以使自己的知识面更加广,思考问题的思路更多 提升自己的毅力 学习新事物会遇到很多困难,通过坚持完成自己定一下的目标，一步一个脚印去走 压力 要有压力才会有动力,如果不努力，没有进步,一直原地踏步，最后就会被新社会淘汰 以上是自己最近的感受😊😊😊, 随便写写 ","link":"https://xiaoai7904.github.io/post/sui-bi/"},{"title":"JavaScript Promis","content":"Promise 解决传统方案回调函数和事件一个新的异步编程解决方案,目前原生Promise已经支持大部分浏览器 目前Promise实现都是遵循Promises/A+规范 英文文档 中文文档 Promise 特点 Promise内部有三种状态 等待态（Pending）、执行态（Fulfilled）、拒绝态（Rejected），三种状态转换关系如下: 等待态（Pending）可以迁移至执行态（Fulfilled）和 拒绝态（Rejected） 执行态（Fulfilled）不能迁移至其他任何状态,必须拥有一个不可变的值（指任何 JavaScript 的合法值） 拒绝态（Rejected）不能迁移至其他任何状态,必须拥有一个不可变的拒绝值（一个 promise 的拒绝原因） Promise内部必须实现then方法,来获取当前值和拒绝值,并且then方法必须返回一个新的Promise对象，需要接受两个函数作为参数onFulfilled和onRejected onFulfilled和onRejected如果不是函数值会被忽略 onFulfilled是函数: 当promise执行结束后其必须被调用，其第一个参数为promise的终值 在promise执行结束前其不可被调用 其调用次数不可超过一次 必须作为函数调用并且异步执行 onRejected是函数: 当promise拒绝执行结束后其必须被调用，其第一个参数为promise的拒绝值 在promise拒绝执行结束前其不可被调用 其调用次数不可超过一次 必须作为函数调用并且异步执行 Promise 基础用法 new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { if(/*成功*/) { resolve(1) }else { reject(2) } }, 1000) }).then( (data) =&gt; { // 调用resolve执行 console.log(data) // 1 }, (err) =&gt; { // 调用reject执行 console.log(err) // 2 } ) 实现 Promise 按照Promises/A+规范自己动手实现Promise,结合规范一步步去实现 定义一个Promise构造函数,接受一个函数作为参数,并且该函数立即执行 class XaPromise&lt;T&gt; { constructor(executor: Executor&lt;T&gt;) { this.initExecutor(executor) } private initExecutor(executor: Executor&lt;T&gt;) { try { executor( (value) =&gt; { this.resolve(value) }, (reason) =&gt; { this.reject(reason) } ) } catch (e) { this.reject(e) } } } new XaPromise((resolve, reject) =&gt; {}) Promise内部有三种状态 等待态（Pending）、执行态（Fulfilled）、拒绝态（Rejected）默认为Pending type statusType = 'pending' | 'fulfilled' | 'rejected' class XaPromise&lt;T&gt; { ['[[PromiseStatus]]']: statusType = 'pending' } Promise内部必须实现then方法,并且then方法必须返回一个新的Promise对象 type statusType = 'pending' | 'fulfilled' | 'rejected' class XaPromise&lt;T&gt; { then(onResolve: any, onReject?: any): XaPromise&lt;T&gt; { return new XaPromise((resolve, reject) =&gt; {}) } } Promise对象then方法处理过程 class XaPromise&lt;T&gt; { then(onResolve: any, onReject?: any): XaPromise&lt;T&gt; { let newXaPromise: any // then 方法必须返回一个 promise 对象 return (newXaPromise = new XaPromise((resolve, reject) =&gt; { let status = this.getPromiseStatus() if (status === 'pending') { this.callbacks.push({ resolve() { try { // 如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行下面的 Promise 解决过程：[[Resolve]](promise2, x) let x = onResolve(this.getPromiseValue()) // 不论 promise1 被 reject 还是被 resolve 时 promise2 都会被 resolve，只有出现异常时才会被 rejected this.handlerResolvePromise(newXaPromise, x, resolve, reject) } catch (e) { // 如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e reject(e) } }, reject() {}, }) } // 省略部分代码 })) } private handlerResolvePromise(newXaPromise: T, x: any, resolve: any, reject: any) {} } Promise解决过程[[Resolve]](promise2, x) x与Promise相等 如果promise和x指向同一对象，以TypeError拒绝执行promise private handlerResolvePromise(newXaPromise: T, x: any, resolve: any, reject: any) { if (x === newXaPromise) { return reject(new TypeError('resolve不能传入当前then返回的Promise对象')) } } x为Promise 如果x处于等待态，promise需保持为等待态直至x被执行或拒绝 如果x处于执行态，用相同的值执行promise 如果x处于拒绝态，用相同的据因拒绝promise private handlerResolvePromise(newXaPromise: T, x: any, resolve: any, reject: any) { if (x instanceof XaPromise) { // 如果 x 处于等待态， promise 需保持为等待态直至 x 被执行或拒绝 if (x['[[PromiseStatus]]'] === 'pending') { x.then( (_value: any) =&gt; { this.handlerResolvePromise(newXaPromise, _value, resolve, reject) }, (_reason: any) =&gt; { reject(_reason) } ) } else { // 如果 x 处于执行态，用相同的值执行 promise // 如果 x 处于拒绝态，用相同的据因拒绝 promise x.then(resolve, reject) } } } x为对象或函数 把x.then赋值给then 如果取x.then的值时抛出错误e ，则以e为据因拒绝promise 如果then是函数，将x作为函数的作用域this调用，传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做rejectPromise 如果resolvePromise以值y为参数被调用，则运行[[Resolve]](promise, y) 如果rejectPromise以据因r为参数被调用，则以据因r拒绝 promise 如果resolvePromise和rejectPromise均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用 如果调用then方法抛出了异常e 如果then不是函数，以x为参数执行promise 如果x不为对象或者函数，以x为参数执行promise private handlerResolvePromise(newXaPromise: T, x: any, resolve: any, reject: any) { let flag = false if (typeof x === 'function' || (x !== null &amp;&amp; typeof x === 'object')) { try { // x 为对象或函数 // 把 x.then 赋值给 then // 如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise let then = x.then // 如果 then 是函数，将 x 作为函数的作用域 this 调用之。传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise if (typeof then === 'function') { then.call( x, (y: any) =&gt; { // 如果 resolvePromise 以值 y 为参数被调用，则运行 [[Resolve]](promise, y) // 如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用 if (flag) return flag = true this.handlerResolvePromise(newXaPromise, y, resolve, reject) }, (r: any) =&gt; { // 如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise // 如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用 if (flag) return flag = true reject(r) } ) } else { // 如果 then 不是函数，以 x 为参数执行 promise reject(x) } } catch (e) { // 如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之 if (flag) return flag = true reject(e) } } } XaPromise源码地址 ","link":"https://xiaoai7904.github.io/post/javascript-promis/"},{"title":"浏览器缓存机制详解","content":"在前端开发中,一个比较重要环节性能优化,然而利用浏览器缓存是性能优化中简单高效的一种优化方式了,一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷 介绍 浏览器缓存主要从以下3点进行讲解: 强缓存 协商缓存 缓存位置 理解以上3点,对于日常面试应该可以和面试官吹吹🐂了😊😊😊😊 强缓存 浏览器缓存分需要发Http请求和不需要发Http请求两种,如果命中强缓存属于不发Http请求,如果没有命中会进行Http请求,但是也会分两种情况,下面会介绍的协商缓存机制,就是要发请求情况。 先看下面一张请求截图 截图上面标红两个字段expires和cache-control,浏览器就是通过这个两个字段进行强缓存判断 Expires 在HTTP/1.0时,浏览器判断是否命中强缓存事通过expires字段 Expires即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求 上面截图中: expires表示在2020-01-8 07:18:24之前都使用缓存数据,如果超过这个时间就需要发送请求向服务器请求数据 使用这种方式会有个问题如果服务器时间和浏览器时间不一样就会出现问题,所以在HTTP/1.1中使用了新的字段来进行判断cache-control Cache-control 在HTTP/1.1时,浏览器判断是否命中强缓存事通过cache-control字段 cache-control采用过期时长来控制缓存，对应的字段如上面截图是max-age字段 上面截图中: cache-control中max-age表示资源会在4320910秒之后失效，失效之后会向服务器发送请求 如上面截图中还有个s-maxage字读是什么意思?,下面详细介绍其中有哪些字段和具体是什么意思 s-maxage: 针对代理服务器的缓存时间 public: 客户端和代理服务器都可以缓存 private: 只有浏览器能缓存了,代理服务器不能缓存 no-cache: 跳过当前的强缓存,发送HTTP请求,即直接进入协商缓存阶段 no-store: 不进行任何缓存 Tips: 如果cache-control和expires同时出现,服务器会优先使用cache-control字段进行判断 协商缓存 强缓存失效之后，浏览器在请求头中携带相应的缓存tag来向服务器发请求，由服务器根据这个tag，来决定是否使用缓存，这就是协商缓存 缓存tag分为两种: Last-Modified 和 Etag Last-Modified 即最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段 浏览器接收到后，如果再次请求，会在请求头中携带If-Modified-Since字段，服务器拿到字段后，会和这个服务器中该资源的最后修改时间对比，对比规则如下： 如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样 否则返回304，告诉浏览器直接用缓存 ETag ETag是服务器根据当前文件的内容，给文件生成的唯一标识的哈希值，只要里面的内容有改动，这个值就会变。服务器通过响应头把这个值给浏览器 浏览器接收到ETag的值，会在下次请求时，将这个值作为If-None-Match这个字段的内容，并放到请求头中，服务器会根据这个值进行对比,对比规则如下: 如果两者不一样，说明要更新了。返回新的资源，跟常规的HTTP请求响应的流程一样 否则返回304，告诉浏览器直接用缓存 两者对比 在准确度上，ETag优于Last-Modified，ETag是监听资源文件是否修改,只要编辑了文件都算修改过，而 Last-Modified 就不一样了，它在一些特殊的情况并不能准确感知资源变化，主要有两种情况: 编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。 Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified并没有体现出修改了。 在性能上，Last-Modified优于ETag，Last-Modified仅仅只是记录一个时间点，而Etag需要根据文件的具体内容生成哈希值。 **Tips:**如果两种方式都支持的话，服务器会优先考虑ETag。 缓存位置 如果浏览器命中缓存,那缓存文件到底存储在哪里？浏览器缓存位置主要有以下几个位置: Service Worker Memory Cache Disk Cache Push Cache Service Worker 对Service Worker详细介绍请查看另一篇文章Service Worker 其中Service Worker Cache就是我们使用的离线缓存 Memory Cache Memory Cache指的是内存缓存，速度是最快的，但是保存时间也是最短的 Disk Cache Disk Cache指的是磁盘存储，存储时间慢，但是保存时间是最长的 Push Cache Push Cache指的是推送缓存，参考文章Creating a Cache-aware HTTP/2 Server Push Mechanism 缓存流程 首先判断是否命中强缓存(Cache-Control和Expires) 如果强缓存可用，直接使用 否则进入协商缓存，即发送HTTP请求，服务器通过请求头中的Last-Modified或者ETag字段检查资源是否更新 若资源更新，返回资源和200状态码 否则，返回304，告诉浏览器直接从缓存获取资源 下面截图是浏览缓存机制流程图： ","link":"https://xiaoai7904.github.io/post/liu-lan-qi-huan-cun-ji-zhi-xiang-jie/"},{"title":"函数节流和防抖","content":"日常开发中会遇到很多事件执行频率很大比如: resize、scroll、mousedown、mousemove... 执行频率越多，对应函数执行次数增多，通过引入节流和防抖可以有效解决这一问题 防抖(debounce) \u0010触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间 示例代码 // 防抖函数 function debounce(fn, wait) { let timer; return function() { let _this = this; let args = arguments; if(timer) { clearTimeout(timer) } timer = setTimeout(function(){ fn.apply(_this, args) }, wait); } } // 使用 window.onresize = debounce(function() {console.log('resize')}, 500) 节流(throttle) 高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率 示例代码 // 方式1: 使用时间戳 function throttle1(fn, wait) { let time = 0; return function() { let _this = this; let args = arguments; let now = Date.now() if(now - time &gt; wait) { fn.apply(_this, args); time = now; } } } // 方式2: 使用定时器 function thorttle2(fn, wait) { let timer; return function () { let _this = this; let args = arguments; if(!timer) { timer = setTimeout(function(){ timer = null; fn.apply(_this, args) }, wait) } } } 上面节流和防抖实现方式比较简单，但是已经可以满足日常使用，如果想更近一步了解可以查看underscore和lodash文档中debounce和thorttle ","link":"https://xiaoai7904.github.io/post/han-shu-jie-liu-he-fang-dou/"},{"title":"JSON.stringify和JSON.parse","content":"在日常开发中，我们会使用到JSON.stringify和JSON.parse对json数据进行转换,也可以通过这两个方法进行数据深度拷贝 JSON.stringify JSON.stringify() 方法将一个 JavaScript 值（对象或者数组）转换为一个 JSON 字符串 语法 JSON.stringify(value[, replacer [, space]]) 参数介绍 value 将要序列化成 一个 JSON 字符串的值 replacer(可选) 如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为 null 或者未提供，则对象所有的属性都会被序列化 space(可选) 指定缩进用的空白字符串，用于美化输出，如果参数是个数字，它代表有多少的空格；上限为10。该值若小于1，则意味着没有空格；如果该参数为字符串（当字符串长度超过10个字母，取其前10个字母），该字符串将被作为空格；如果该参数没有提供（或者为 null），将没有空格 转换注意事项 转换值如果有 toJSON() 方法，该方法定义什么值将被序列化。 非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中。 布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值。 undefined、任意的函数以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成null（出现在数组中时）。函数、undefined 被单独转换时，会返回 undefined，如JSON.stringify(function(){}) or JSON.stringify(undefined) 对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误 所有以 symbol 为属性键的属性都会被完全忽略掉，即便 replacer 参数中强制指定包含了它们。 Date日期调用了 toJSON() 将其转换为了 string 字符串（同Date.toISOString()），因此会被当做字符串处理。 NaN 和 Infinity 格式的数值及 ull 都会被当做 null 其他类型的对象，包括 Map/Set/WeakMap/WeakSet，仅会序列化可枚举的属性 toJSON 方法 如果一个被序列化的对象拥有 toJSON 方法，那么该 toJSON 方法就会覆盖该对象默认的序列化行为：不是该对象被序列化，而是调用 toJSON 方法后的返回值会被序列化，示例如下: let obj = { a: 'a', toJSON: function () { return 'a'; } }; JSON.stringify(obj); // '&quot;a&quot;' JSON.stringify({x: obj}); // '{&quot;x&quot;:&quot;a&quot;}' 示例代码: let obj = { a: '1', b: 1, c: function() { return 1 } } // 通过JSON.stringify方法进行字符串序列化 let str = JSON.stringify(obj) // 函数会被忽略,详情见上面 转换注意事项 console.log(str) // &quot;{&quot;a&quot;:&quot;1&quot;,&quot;b&quot;:1}&quot; // 可以通过JSON.stringify第一个参数进行特殊处理 let str = JSON.stringify(obj, function(key, value) { if(typeof value === 'function') { return value.toString() } return value }) console.log(str) // &quot;{&quot;a&quot;:&quot;1&quot;,&quot;b&quot;:1,&quot;c&quot;:&quot;function() { return 1 }&quot;}&quot; JSON.parse 语法 JSON.parse(text[, reviver]) 参数介绍 text 要被解析成 JavaScript 值的字符串 reviver(可选) 转换器, 如果传入该参数(函数)，可以用来修改解析生成的原始值，调用时机在 parse 函数返回之前 注意事项 JSON.parse()不允许用逗号作为结尾 示例代码 let str = &quot;{&quot;a&quot;:&quot;1&quot;,&quot;b&quot;:1,&quot;c&quot;:&quot;function() { return 1 }&quot;}&quot; let obj = JSON.parse(str) console.log(obj); // {a: '1', b: 1, c: 'function() {return 1}'} // 如果想函数转换成可执行函数 let obj = JSON.parse(str, function(key, value) { // 也可以判断value中是否有function字段 if(key === 'c') { return eval(&quot;(function(){return &quot; + value + &quot; })()&quot;) } return value }) console.log(obj); // {a: '1', b: 1, c: function() {return 1}} 深度拷贝对象 可以通过JSON.stringify和JSON.parse进行数据拷贝, 数据中不应该有function, undefined因为它们会被忽略 let obj = {a: 1, b: { b1: 11 }} let copyObj = JSON.parse(JSON.stringify(obj)) console.log(obj === copyObj); // false ","link":"https://xiaoai7904.github.io/post/jsonstringify-he-jsonparse/"},{"title":"Service Worker","content":"丰富的离线体验、定期的后台同步以及推送通知等通常需要将面向本机应用的功能将引入到网页应用中。 Service Worker 提供所有这些功能所依赖的技术基础。 什么是 Service Worker Service Worker 是浏览器在后台独立于网页运行的脚本，它打开了通向不需要网页或用户交互的功能的大门。 现在，它们已包括如推送通知和后台同步等功能。 将来，Service Worker 将会支持如定期同步或地理围栏等其他功能。 本教程讨论的核心功能是拦截和处理网络请求，包括通过程序来管理缓存中的响应。 这个 API 之所以令人兴奋，是因为它可以支持离线体验，让开发者能够全面控制这一体验。 在 Service Worker 出现前，存在能够在网络上为用户提供离线体验的另一个 API，称为 AppCache。 AppCache API 存在的许多相关问题，在设计 Service Worker 时已予以避免。 Service Worker 相关注意事项： 它是一种 JavaScript Worker，无法直接访问 DOM。 Service Worker 通过响应 postMessage 接口发送的消息来与其控制的页面通信，页面可在必要时对 DOM 执行操作。 Service Worker 是一种可编程网络代理，让您能够控制页面所发送网络请求的处理方式。 Service Worker 在不用时会被中止，并在下次有需要时重启，因此，您不能依赖 Service Worker onfetch 和 onmessage 处理程序中的全局状态。 如果存在您需要持续保存并在重启后加以重用的信息，Service Worker 可以访问 IndexedDB API。 Service Worker 广泛地利用了 promise，因此如果您不熟悉 promise，则应停下阅读此内容，看一看 Promise 简介。 Service Worker 生命周期 Service Worker 的生命周期完全独立于网页。 要为网站安装服务工作线程，您需要先在页面的 JavaScript 中注册。 注册服务工作线程将会导致浏览器在后台启动服务工作线程安装步骤。 在安装过程中，您通常需要缓存某些静态资产。 如果所有文件均已成功缓存，那么 Service Worker 就安装完毕。 如果任何文件下载失败或缓存失败，那么安装步骤将会失败，Service Worker 就无法激活（也就是说， 不会安装）。 如果发生这种情况，不必担心，它下次会再试一次。 但这意味着，如果安装完成，您可以知道您已在缓存中获得那些静态资产。 安装之后，接下来就是激活步骤，这是管理旧缓存的绝佳机会，我们将在 Service Worker 的更新部分对此详加介绍。 激活之后，Service Worker 将会对其作用域内的所有页面实施控制，不过，首次注册该 Service Worker 的页面需要再次加载才会受其控制。 服务工作线程实施控制后，它将处于以下两种状态之一：服务工作线程终止以节省内存，或处理获取和消息事件，从页面发出网络请求或消息后将会出现后一种状态。 以下是 Service Worker 初始安装时的简化生命周期。 浏览器支持 可用的浏览器日益增多。 Service Worker 受 Chrome、Firefox 和 Opera 支持。 Microsoft Edge 现在表示公开支持。 甚至 Safari 也暗示未来会进行相关开发。 您可以在 Jake Archibald 的 is Serviceworker ready 网站上查看所有浏览器的支持情况 。 您需要 HTTPS 在开发过程中，可以通过 localhost 使用 Service Worker，但如果要在网站上部署 Service Worker，则需要在服务器上设置 HTTPS。 使用服务工作线程，您可以劫持连接、编撰以及过滤响应。 这是一个很强大的工具。 您可能会善意地使用这些功能，但中间人可会将其用于不良目的。 为避免这种情况，可仅在通过 HTTPS 提供的页面上注册 Service Worker，如此我们便知道浏览器接收的 Service Worker 在整个网络传输过程中都没有被篡改。 Github 页面 通过 HTTPS 提供，因此这些页面是托管演示的绝佳位置。 如果想要向服务器添加 HTTPS，您需要获得 TLS 证书并在服务器上进行设置。 具体因您的设置而异，因此请查看服务器的文档，并务必查阅 Mozilla SSL 配置生成器，了解最佳做法。 注册 Service Worker 若要安装 Service Worker，您需要通过在页面中对其进行注册来启动安装。 这将告诉浏览器 Service Worker JavaScript 文件的位置。 if ('serviceWorker' in navigator) { window.addEventListener('load', function() { navigator.serviceWorker.register('/sw.js').then(function(registration) { // Registration was successful console.log('ServiceWorker registration successful with scope: ', registration.scope); }, function(err) { // registration failed :( console.log('ServiceWorker registration failed: ', err); }); }); } 此代码用于检查 Service Worker API 是否可用，如果可用，则在页面加载后注册位于 /sw.js 的 Service Worker。 每次页面加载无误时，即可调用 register()；浏览器将会判断服务工作线程是否已注册并做出相应的处理。 register() 方法的精妙之处在于服务工作线程文件的位置。 您会发现在本例中服务工作线程文件位于根网域。 这意味着服务工作线程的作用域将是整个来源。 换句话说，Service Worker 将接收此网域上所有事项的 fetch 事件。 如果我们在 /example/sw.js 处注册 Service Worker 文件，则 Service Worker 将只能看到网址以 /example/ 开头（即 /example/page1/、/example/page2/）的页面的 fetch 事件。 现在，您可以通过转至 chrome://inspect/#service-workers 并寻找您的网站来检查 Service Worker 是否已启用。 首次实施 Service Worker 时，您还可以通过 chrome://serviceworker-internals 来查看 Service Worker 详情。 如果只是想了解 Service Worker 的生命周期，这仍很有用，但是日后其很有可能被 chrome://inspect/#service-workers 完全取代。 您会发现，它还可用于测试隐身窗口中的服务工作线程，您可以关闭服务工作线程并重新打开，因为之前的服务工作线程不会影响新窗口。 从无痕式窗口创建的任何注册和缓存在该窗口关闭后均将被清除。 安装 Service Worker 在受控页面启动注册流程后，我们来看看处理 install 事件的 Service Worker 脚本。 最基本的例子是，您需要为安装事件定义回调，并决定想要缓存的文件。 self.addEventListener('install', function(event) { // Perform install steps }); 在 install 回调的内部，我们需要执行以下步骤： 打开缓存。 缓存文件。 确认所有需要的资产是否已缓存。 var CACHE_NAME = 'my-site-cache-v1'; var urlsToCache = [ '/', '/styles/main.css', '/script/main.js' ]; self.addEventListener('install', function(event) { // Perform install steps event.waitUntil( caches.open(CACHE_NAME) .then(function(cache) { console.log('Opened cache'); return cache.addAll(urlsToCache); }) ); }); 此处，我们以所需的缓存名称调用 caches.open()，之后再调用 cache.addAll() 并传入文件数组。 这是一个 promise 链（caches.open() 和 cache.addAll()）。 event.waitUntil() 方法带有 promise 参数并使用它来判断安装所花费的时间，以及安装是否成功。 如果所有文件都成功缓存，则将安装 Service Worker。 如有任何文件无法下载，则安装步骤将失败。 这可让您依赖于所定义的所有资产，但也意味着需要对您决定在安装步骤缓存的文件列表格外留意。 定义一个过长的文件列表将会增加文件缓存失败的几率，从而导致服务工作线程未能安装。 这仅是一个示例，实际您可以在 install 事件中执行其他任务，或完全避免设置 install 事件侦听器。 缓存和返回请求 您已安装 Service Worker，现在可能会想要返回一个缓存的响应，对吧？ 在安装 Service Worker 且用户转至其他页面或刷新当前页面后，Service Worker 将开始接收 fetch 事件。下面提供了一个示例。 self.addEventListener('fetch', function(event) { event.respondWith( caches.match(event.request) .then(function(response) { // Cache hit - return response if (response) { return response; } return fetch(event.request); } ) ); }); 这里我们定义了 fetch 事件，并且在 event.respondWith() 中，我们传入来自 caches.match() 的一个 promise。 此方法检视该请求，并从服务工作线程所创建的任何缓存中查找缓存的结果。 如果发现匹配的响应，则返回缓存的值，否则，将调用 fetch 以发出网络请求，并将从网络检索到的任何数据作为结果返回。 这是一个简单的例子，它使用了在安装步骤中缓存的所有资产。 如果希望连续缓存新请求，可以通过处理 fetch 请求的响应并将其添加到缓存来实现，如下所示。 self.addEventListener('fetch', function(event) { event.respondWith( caches.match(event.request) .then(function(response) { // Cache hit - return response if (response) { return response; } // IMPORTANT:Clone the request. A request is a stream and // can only be consumed once. Since we are consuming this // once by cache and once by the browser for fetch, we need // to clone the response. var fetchRequest = event.request.clone(); return fetch(fetchRequest).then( function(response) { // Check if we received a valid response if(!response || response.status !== 200 || response.type !== 'basic') { return response; } // IMPORTANT:Clone the response. A response is a stream // and because we want the browser to consume the response // as well as the cache consuming the response, we need // to clone it so we have two streams. var responseToCache = response.clone(); caches.open(CACHE_NAME) .then(function(cache) { cache.put(event.request, responseToCache); }); return response; } ); }) ); }); 执行的操作如下： 在 fetch 请求中添加对 .then() 的回调。 获得响应后，执行以下检查： 确保响应有效。 检查并确保响应的状态为 200。 确保响应类型为 basic，亦即由自身发起的请求。 这意味着，对第三方资产的请求也不会添加到缓存。 如果通过检查，则克隆响应。 这样做的原因在于，该响应是数据流， 因此主体只能使用一次。 由于我们想要返回能被浏览器使用的响应，并将其传递到缓存以供使用，因此需要克隆一份副本。我们将一份发送给浏览器，另一份则保留在缓存。 更新 Service Worker 在某个时间点，您的 Service Worker 需要更新。 此时，您需要遵循以下步骤： 更新您的服务工作线程 JavaScript 文件。 用户导航至您的站点时，浏览器会尝试在后台重新下载定义 Service Worker 的脚本文件。 如果 Service Worker 文件与其当前所用文件存在字节差异，则将其视为新 Service Worker。 新 Service Worker 将会启动，且将会触发 install 事件。 此时，旧 Service Worker 仍控制着当前页面，因此新 Service Worker 将进入 waiting 状态。 当网站上当前打开的页面关闭时，旧 Service Worker 将会被终止，新 Service Worker 将会取得控制权。 新 Service Worker 取得控制权后，将会触发其 activate 事件。 出现在 activate 回调中的一个常见任务是缓存管理。 您希望在 activate 回调中执行此任务的原因在于，如果您在安装步骤中清除了任何旧缓存，则继续控制所有当前页面的任何旧 Service Worker 将突然无法从缓存中提供文件。 比如说我们有一个名为 'my-site-cache-v1' 的缓存，我们想要将该缓存拆分为一个页面缓存和一个博文缓存。 这就意味着在安装步骤中我们创建了两个缓存：'pages-cache-v1' 和 'blog-posts-cache-v1'，且在激活步骤中我们要删除旧的 'my-site-cache-v1'。 以下代码将执行此操作，具体做法为：遍历 Service Worker 中的所有缓存，并删除未在缓存白名单中定义的任何缓存。 self.addEventListener('activate', function(event) { var cacheWhitelist = ['pages-cache-v1', 'blog-posts-cache-v1']; event.waitUntil( caches.keys().then(function(cacheNames) { return Promise.all( cacheNames.map(function(cacheName) { if (cacheWhitelist.indexOf(cacheName) === -1) { return caches.delete(cacheName); } }) ); }) ); }); 瑕疵和问题 如果安装失败，我们未必能告知您详情 如果 Worker注册后未在 chrome://inspect/#service-workers 或 chrome://serviceworker-internals 中显示，则有可能是引发错误或向 event.waitUntil() 发送被拒绝的 promise 而导致无法安装。 要解决该问题，请转至 chrome://serviceworker-internals 并勾选“Open DevTools window and pause JavaScript execution on service worker startup for debugging”，然后将调试程序语句置于安装事件开始处。 这与未捕获异常中的暂停共同揭露问题。 fetch() 默认值 默认情况下没有凭据 使用 fetch 时，默认情况下请求中不包含 Cookie 等凭据。 如需凭据，改为调用： fetch(url, { credentials: 'include' }) 这一行为是有意为之，可以说比 XHR 更复杂的以下默认行为更好：如果网址具有相同来源，则默认发送凭据，否则忽略。 提取的行为更接近于其他 CORS 请求，如 &lt;img crossorigin&gt;，它将决不会发送 Cookie，除非您使用 &lt;img crossorigin=&quot;use-credentials&quot;&gt; 选择加入。 非 CORS 默认失败 默认情况下，从不支持 CORS 的第三方网址中提取资源将会失败。 您可以向请求中添加 no-CORS 选项来克服此问题，不过这可能会导致“不透明”的响应，这意味着您无法辨别响应是否成功。 cache.addAll(urlsToPrefetch.map(function(urlToPrefetch) { return new Request(urlToPrefetch, { mode: 'no-cors' }); })).then(function() { console.log('All resources have been fetched and cached.'); }); 处理响应式图像 srcset 属性或 元素将在运行期间选择最适当的图像资产，并发出网络请求。 对于 Service Worker，如果您想要在安装过程中缓存图像，您有下列几种选择： 安装 元素和 srcset 属性将请求的所有图像。 安装一个低分辨率版本的图像。 安装一个高分辨率版本的图像。 实际上，您应该选择 2 或 3，因为下载所有图像会浪费存储空间。 假定您在安装期间选择安装低分辨率版本的图像，在页面加载时您想要尝试从网络中检索高分辨率的图像，但是如果检索高分辨率版本失败，则回退到低分辨率版本。 这没有问题，而且这种做法很好，但是有另外一个问题。 如果我们有以下两张图像： 屏幕密度 宽度 高度 1x 400 400 2x 800 800 在 srcset 图像中，我们有一些像这样的标记： &lt;img src=&quot;image-src.png&quot; srcset=&quot;image-src.png 1x, image-2x.png 2x&quot; /&gt; 如果我们使用的是 2x 显示屏，浏览器将会选择下载 image-2x.png。如果我们处于离线状态，您可以对请求执行 .catch() 并返回 image-src.png（如已缓存）。但是，浏览器会期望 2x 屏幕上的图像有额外的像素，这样图像将显示为 200x200 CSS 像素而不是 400x400 CSS 像素。 解决该问题的唯一办法是设定固定的图像高度和宽度。 &lt;img src=&quot;image-src.png&quot; srcset=&quot;image-src.png 1x, image-2x.png 2x&quot; style=&quot;width:400px; height: 400px;&quot; /&gt; 对于要用于艺术指导的 &lt;picture&gt; 元素，这会变得相当困难，而且很大程度上取决于图像的创建和使用方式，但是您可以使用类似于 srcset 的方法。 ","link":"https://xiaoai7904.github.io/post/service-worker/"},{"title":"CSS BEM书写规","content":"BEM的意思就是块（block）、元素（element）、修饰符（modifier）,是由Yandex团队提出的一种前端命名方法论。这种巧妙的命名方法让你的CSS类对其他开发者来说更加透明而且更有意义。BEM命名约定更加严格，而且包含更多的信息，它们用于一个团队开发一个耗时的大项目 介绍 \b如果你是一个Vue爱好者，并且你是一个喜欢\b接受新鲜事物和\b追求技术\b高度,那么你一定\b使用或者知道Element-Ui(\b或者其他UI库),在element-ui中你去观察它的源码你会发现它的组件css的定义方式 @include b(tree-node) { white-space: nowrap; outline: none; &amp;:focus { /* focus */ &gt; .el-tree-node__content { background-color: $--tree-node-hover-color; } } @include when(drop-inner) { &gt; .el-tree-node__content .el-tree-node__label { background-color: $--color-primary; color: #fff; } } } 上面代码是element-ui中组件tree组件的部分样式 \b\b不难从上面代码中可以看到element-ui是怎么来命名class类名和sass变量\b都使用了-,__,'--'这个连\b字符,下面我们介绍为什么要这样写,这样写的好处是什么 BEM BEM代表“块（block）,元素（element）,修饰符（modifier”,我们常用这三个实体开发组件。 在选择器中，由以下三种符合来表示扩展的关系: - 中划线 ：仅作为连字符使用，表示某个块或者某个子元素的多单词之间的连接记号 __ 双下划线：双下划线用来连接块和块的子元素 _ 单下划线：单下划线用来描述一个块或者块的子元素的一种状态 type-block__element_modifier 块（block） 一个块是设计或布局的一部分，它有具体且唯一地意义 ，要么是语义上的要么是视觉上的 例如我们有一个菜单列表 &lt;ul class=&quot;menu&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;/ul&gt; \b类名menu就是代表菜单这个块或者区域 元素（element） 块中的子元素是块的子元素，并且子元素的子元素在 bem 里也被认为是块的直接子元素。一个块中元素的类名必须用父级块的名称作为前缀 &lt;ul class=&quot;menu&quot;&gt; &lt;li class=&quot;menu__item&quot;&gt;1&lt;/li&gt; &lt;li class=&quot;menu__item&quot;&gt;2&lt;/li&gt; &lt;/ul&gt; 类名menu__item中的__item就是代表元素项 修饰符（modifier） 一个“修饰符”可以理解为一个块的特定状态，标识着它持有一个特定的属性 &lt;ul class=&quot;menu&quot;&gt; &lt;li class=&quot;menu__item menu__item-actived&quot;&gt;1&lt;/li&gt; &lt;li class=&quot;menu__item&quot;&gt;2&lt;/li&gt; &lt;/ul&gt; 类名menu__item-actived中的-actived代表修饰符 可供选择的命名方案 \bBEM只是一种命名约定方案不一定要按照固定写法\b来执行,主要是在项目中要保持一致的命名约定即可 下面有几种方案提供\b\b参考 Two Dashes style（双连字符风格） block-name__elem-name--mod-name 名字全部使用小写 BEM 实体的名称中的每一个单词使用一个连字符分隔 使用双下划线（__）将元素的名称和模块的名称分离开 使用双连字符（--）分隔 Boolean 类型的修饰符 不使用 key-value 类型的修饰符 CamelCase style（驼峰命名风格） MyBlock__SomeElem_modName_modVla 这种风格的命名方案的不同点在于，在BEM实体中分隔单词时使用驼峰命名法代替了一个连字符（-） &quot;Sans underscore&quot; style（无下划线风格） blockName-elemName--modName--modVal 名称使用驼峰命名法书写 元素名称与模块名称使用一个连字符（-）分隔 修饰符使用双连字符（--）与模块或元素分隔 修饰符的名称和值使用双连字符（--）分隔 BEM方法论为BEM实体的命名提供了基本的原则。选择哪一种命名方式取决于你项目的需求和你的个人喜好。使用方法论中提到的命名约定的一大优势在于具有现成的面向“经典命名”的开发工具 文章参考 【译】BEM CSS命名规范三 Naming convention W3cschool Yandex BEM/OOCSS ","link":"https://xiaoai7904.github.io/post/css-bem-shu-xie-gui/"},{"title":"前端大杂烩","content":"整理目前github\b上面比较优秀和热门的项目,文章，方便查看和学习 2019-11-23更新 NeteaseCloudMusicApi 网易云音乐 Node.js API service iDataV 大屏数据可视化 Administrative-divisions-of-China 城市数据JSON 2019-4-16更新 Octotree GitHub code tree on steroids Twemoji Emoji for everyone. AreaCity-JsSpider-StatsGov 国家统计局中的省市区镇行政区划数据带拼音标注，高德地图的坐标和行政区域边界范围，在浏览器里面运行js代码采集的2019年发布的最新数据，含采集源码. You-Dont-Need-jQuery Examples of how to do query, style, dom, ajax, event etc like jQuery with plain javascript. laxxx Simple &amp; light weight (3kb minified &amp; zipped) vanilla javascript plugin to create smooth &amp; beautiful animations when you scrolllll! Harness the power of the most intuitive interaction and make your websites come alive! AutoPiano 自由钢琴 AutoPiano 2019-2-15更新 Motrix 基于Electron Vue + VueX + Element开发 2018-1-13更新 CSS-Inspiration CSS Inspiration，在这里找到写 CSS 的灵感 anime JavaScript animation engine reveal 幻灯片展示框架 2018-12-23更新 tui.calendar 一个JavaScript日历 vue-html Vue模板和Vue JSX的替代品 Blog Vue模板和Vue JSX的替代品 strapi Vue模板和Vue JSX的替代品 Boostnote 适用于Mac，Windows和Linux的开发人员的降价编辑器 htm 使用标准标记模板的JSX替代方案，具有编译器支持 nodebestpractices 最大的Node.JS最佳实践列表 2018-12-17更新 forever 一个简单的CLI工具，用于确保给定脚本连续运行 connect-history-api-fallback 对于使用HTML 5历史记录API的应用程序 Android 和 IOS 使用 WebViewJavascriptBridge 进行交互方法 CentOS 7部署Node.js+MongoDB Vultr注册及VPS购买图文教程 在CentOS VPS上通过SSH安装 MySQL 你（可能）不知道的web api Fre：又一个小而美的前端MVVM框架 Eruda 一个被人遗忘的调试神器 前端接受后端文件流并下载的几种方法 2018-12-10更新 video.js 开源HTML5和Flash视频播放器 2018-12-8更新 sharp 用于高效处理图像的node.js模块 three.js 一款javascript 3D库 jsPDF jsPDF 客服端PDF生成工具 前端构建：3 类 13 种热门工具的选型参考 来自微信公众号 2018-12-6更新 free-programming-books-zh_CN 免费的计算机编程类中文书籍 Charles 从入门到精通 mac charles网络抓包软件教程 深入理解 TypeScript 一本中文TypeScript的教程书，原版(英文版本)typescript-book 初探 Vue3.0 中的一大亮点——Proxy ! 掘金原创文章 2018-12-3更新 fx ensorSpace是一套用于构建神经网络3D可视化应用的框架 tensorspace命令行工具和终端JSON查看器 slate可定制富文本编辑器 react-beautiful-dndreact 可拖拽ui列表 2018-12-1更新 GoJS 用于交互式流程图，组织结构图，设计工具，规划工具，可视语言的JavaScript图表库 TS 版 Promise 详解 掘金原创文章 小程序云开发教程 掘金原创文章 JS函数节流和函数防抖 掘金原创文章 细解JavaScript ES7 ES8 ES9 新特性 2018-11-29更新 Vue \b用于构建用户界面的渐进式框架 React Facebook出品,用于构建用户界面的JS库 Node 基于V8引擎的javascript runtime axios 利用Promise\b编写的HTTP客服端 puppeteer 谷歌\b维护Node库,它提供了一个高级API来控制DevTools协议上的Chrome或Chromium,可以用着前端自动化测试,爬虫等 NervJs/taro 多端统一开发框架，支持用 React的开发方式编写一次代码，生成能运行在微信小程序/百度智能小程序/支付宝小程序、H5、React Native 等的应用 Omi 腾讯出品，4kb JavaScript中的下一代Web框架（Web Components + JSX + Proxy + Store + Path Updating),易于MVVM Mermaid 一个生成流程图的工具 learnGitBranching 在线学git命令的使用,一个交互式的git可视化来挑战和学习 progress-estimator 记录进度条并估算Promise完成所需的时间 event-stream EventStream is like functional programming meets IO 30-seconds-of-code 精选的有用JavaScript代码段集合，您可以在30秒或更短的时间内理解这些代码段 ImageRevealHover 一组链接悬停效果，以不同的创作方式显示缩略图 htm 使用标准标记模板的JSX替代方案，具有编译器支持 airbnb/javascript javascript代码规范和es-lint相关配置 document-library jsliang 的文档库. 里面包含了所有的前端文章，例如 vue、react,、angular、微信小程序、设计模式等…… mpvue 基于 Vue.js 的小程序开发框架，从底层支持 Vue.js 语法和构建工具体系 element-ui 基于 Vue 2.0 桌面ui库 iview 基于 Vue 2.0 桌面ui库 awesome-vue 基于Vue优秀插件集合 持续更新... ","link":"https://xiaoai7904.github.io/post/qian-duan-da-za-hui/"},{"title":"vue源码解析,自己动手实现miniVue","content":"通过对Vue源码进行阅读,自己动手实现miniVue框架 miniVue mini 版本 Vue,实现了 Vue 最核心部分代码,该项目是为了对 Vue 有更加深入了解,根据对源码剖析和自己的理解模拟 Vue 写的 mini 版本的 Vue github源码地址 目前没有实现diff算法,每次都是强制更新dom 实例 &lt;!-- 如果使用MiniVue.min.js在实例化用new MiniVue.min进行实例化- --&gt; &lt;!-- 如果使用MiniVue.es5.js在实例化用new MiniVue.es5进行实例化- --&gt; &lt;script src=&quot;../dist/MiniVue.js&quot;&gt;&lt;/script&gt; &lt;div id=&quot;app&quot; class=&quot;aa&quot; :class=&quot;classFn&quot; style=&quot;font-size: 20px&quot; :style=&quot;styleFn&quot;&gt; &lt;div&gt;{{a}}&lt;/div&gt; &lt;input type=&quot;text&quot; v-model=&quot;a&quot; /&gt; &lt;button @click=&quot;clickFn&quot;&gt;xx&lt;/button&gt; &lt;/div&gt; new MiniVue({ el: '#app', data() { return { a: 1, color: '#999', classFn: 'bb' }; }, computed: { styleFn() { return { color: this.color }; } }, methods: { clickFn() { console.log('clickFn'); this.a = this.a === 33333 ? 2222 : 33333; this.color = this.color === 'red' ? '#000' : 'red'; } }, created() { console.log('created'); }, beforeMount() { console.log('beforeMount'); }, beforeUpdate() { console.log('beforeUpdate'); }, mounted() { console.log('mounted'); setTimeout(() =&gt; { this.a = 2222; }, 1000 * 3); } }); 文件目录 Comilper---&gt;主要是处理dom编译 Instance---&gt;程序入口和创建dom Observer---&gt;数据拦截,数据订阅，发布，更新 Util---&gt;程序工具类(debug,nextTick...) 深入响应式原理 先看一张Vue官方文档中的图 当你把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器。 这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。这里需要注意的问题是浏览器控制台在打印数据对象时 getter/setter 的格式化并不同，所以你可能需要安装 vue-devtools 来获取更加友好的检查接口。 每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新 MiniVue\b 响应式原理 MiniVue 是对 Vue 进行 深度学习得等的 产品,大部分代码都是来源Vue源码，\b 在MiniVue中使用了Object.defineProperty()进行数据劫持,来监听setter和getter 数据初始化劫持 /** * 初始化data对象数据,收集数据添加监听 */ _initData() { let vm = this; let data = this.$options.data; // data支持两种写法(函数和对象) // 如果data是函数就直接执行拿到返回值,如果是对象直接返回 data = vm._data = typeof data === 'function' ? data.call(vm) : data || {}; const keys = Object.keys(data); let i = keys.length; while (i--) { let key = keys[i]; this.proxy(vm, '_data', key); } observe(data, vm); } 核心代码 Object.defineProperty(obj, key, { // 可枚举 enumerable: true, configurable: true, get: function reactiveGetter() { const value = getter ? getter.call(obj) : val; // 依赖收集 if (Dep.target) { dep.depend(); } return value; }, set: function reactiveSetter(newVal) { const value = getter ? getter.call(obj) : val; if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) { return; } // 更新值 if (setter) { setter.call(obj, newVal); } else { val = newVal; } // 新的值是object的话，进行监听 childObj = observe(newVal); // 通知所有订阅者进行视图更新 dep.notify(); } }); 这样我们已经可以监听每个数据的变化了，那么监听到变化之后就通知订阅者，所以接下来我们需要实现一个消息订阅器，维护一个数组，用来收集订阅者，数据变动触发notify，再调用订阅者的update方法 /** * 订阅者Dep * 主要作用是用来存放Watcher观察者对象 */ export default class Dep { constructor() { // 标示id防止添加重复观察者对象 this.id = uid++; // 存储观察者对象 this.subs = []; } /** * 添加观察者 * @param {Watcher对象} sub */ addSub(sub) { this.subs.push(sub); } /** * 通知所有订阅者 * update方法是挂载在Watcher原型对象上面的,方法内部会把需要的更新数据push到异步队列中,等到数据所有操作完成在进行视图更新 */ notify() { // 拷贝观察者对象 const subs = this.subs.slice(); // 循环所有观察者进行更新操作 subs.map(item =&gt; { item.update(); return item; }); } } 总结: 响应式原理 ---&gt; 初始化会获取data里面的数据，进行数据劫持使用Object.defineProperty进行数据劫持,对data里面的每一条数据进行setter和getter,当有获取数据触发getter进行依赖收集,当有数据发生改变触发setter更新数据,\b并且通知订阅者触发更新 MiniVue AST 内部通过遍历 html 文档树，通过正则匹配转换成AST树 /** * html转为Ast * @returns Object AST语法树 */ _convertHtml2Ast() { while (this.template) { let textEnd = this.template.indexOf('&lt;'); if (textEnd === 0) { // 如果是注释标签直接跳过编译 if (regExp.comment.test(this.template)) { let commentEnd = this.template.indexOf('--&gt;'); this._advance(commentEnd + 3); continue; } // 匹配结束标签 let endTagMatch = this.template.match(regExp.endTag); if (endTagMatch) { let _index = this.index; this._advance(endTagMatch[0].length); this._parseEndTag(endTagMatch[1], _index, this.index); continue; } // 匹配开始标签 let startTagMatch = this._parseStartTag(); if (startTagMatch) { this._handleStartTag(startTagMatch); continue; } } } } for (var i = 0, l = attrs.length; i &lt; l; i++) { map[attrs[i].name] = attrs[i].value; /** * 1.匹配 @ 符号表示是绑定事件 * 2.匹配 :class :style 表达式class和表达式style * 3.匹配 class style 静态class和静态style * 4.普通数据(如: id) */ if (attrs[i].name.match(/^@/g)) { isEvent = true; event[attrs[i].name.match(/\\w*$/)[0]] = { value: attrs[i].value }; } else if (class2styleReg.test(attrs[i].name)) { attrs[i].name.indexOf('class') &gt; -1 ? (staticClass = attrs[i].value) : (staticStyle = attrs[i].value); } else if (class2styleExpReg.test(attrs[i].name)) { attrs[i].name.indexOf(':class') &gt; -1 ? (classBinding = attrs[i].value) : (styleBinding = attrs[i].value); } else if (attrs[i].name === 'v-model') { isEvent = true; event['input'] = { value: `function($event){if($event.target.composing)return;${attrs[i].value}=$event.target.value}` }; props.push({ name: 'value', value: `(${attrs[i].value})` }); directives.push({ arg: null, modifiers: undefined, name: 'model', rawName: 'v-model', value: attrs[i].value }); } else { _attrs.push({ name: attrs[i].name, value: attrs[i].value }); } } // 默认根ast数据结构 var astMap = { type: 1, tag: startTagMatch.tagName, attrsList: attrs, attrsMap: map, parent: parent, children: [] }; 通过正则匹配把 Html 转为为 AST 树 结构如下: MiniVue VNode VNode(虚拟Dom) 可以把真实 DOM 树抽象成一棵以 JavaScript 对象构成的抽象树，在修改抽象树数据后将抽象树转化成真实 DOM 重绘到页面上呢？于是虚拟 DOM 出现了，它是真实 DOM 的一层抽象，用属性描述真实 DOM 的各个特性。当它发生变化的时候，就会去修改视图。 可以想象，最简单粗暴的方法就是将整个 DOM 结构用 innerHTML 修改到页面上，但是这样进行重绘整个视图层是相当消耗性能的，我们是不是可以每次只更新它的修改呢？所以 Vue.js 将 DOM 抽象成一个以 JavaScript 对象为节点的虚拟 DOM 树，以 VNode 节点模拟真实 DOM，可以对这颗抽象树进行创建节点、删除节点以及修改节点等操作，在这过程中都不需要操作真实 DOM，只需要操作 JavaScript 对象后只对差异修改，相对于整块的 innerHTML 的粗暴式修改，大大提升了性能。修改以后经过 diff 算法得出一些需要修改的最小单位，再将这些小单位的视图进行更新。这样做减少了很多不需要的 DOM 操作，大大提高了性能。 Vue 就使用了这样的抽象节点 VNode，它是对真实 DOM 的一层抽象，而不依赖某个平台，它可以是浏览器平台，也可以是 weex，甚至是 node 平台也可以对这样一棵抽象 DOM 树进行创建删除修改等操作，这也为前后端同构提供了可能 export default class VNode { constructor(tag, data, children, text, elm, context, componentOptions, asyncFactory) { /*当前节点的标签名*/ this.tag = tag; /*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*/ this.data = data; /*当前节点的子节点，是一个数组*/ this.children = children; /*当前节点的文本*/ this.text = text; /*当前虚拟节点对应的真实dom节点*/ this.elm = elm; /*当前节点的名字空间*/ this.ns = undefined; /*编译作用域*/ this.context = context; /*函数化组件作用域*/ this.functionalContext = undefined; /*节点的key属性，被当作节点的标志，用以优化*/ this.key = data &amp;&amp; data.key; /*组件的option选项*/ this.componentOptions = componentOptions; /*当前节点对应的组件的实例*/ this.componentInstance = undefined; /*当前节点的父节点*/ this.parent = undefined; /*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*/ this.raw = false; /*静态节点标志*/ this.isStatic = false; /*是否作为跟节点插入*/ this.isRootInsert = true; /*是否为注释节点*/ this.isComment = false; /*是否为克隆节点*/ this.isCloned = false; /*是否有v-once指令*/ this.isOnce = false; } child() { return this.componentInstance; } } 会根据生成的AST树转换成 \brender 函数，render 函数创建每个节点 VNode render 函数 &quot;with(this){return _c('div',{staticClass:&quot;aa bb&quot;,class:classFn,staticStyle:{&quot;width&quot;:&quot;200px&quot;,&quot;height&quot;:&quot;50px&quot;},style:(styleFn),attrs:{&quot;id&quot;:&quot;app&quot;}},[_c('input',{directives:[{name:&quot;model&quot;,rawName:&quot;v-model&quot;,value:(testData),expression:&quot;testData&quot;}],attrs:{&quot;type&quot;:&quot;text&quot;,&quot;name&quot;:&quot;&quot;},domProps:{&quot;value&quot;:(testData)},on:{&quot;input&quot;:function($event){if($event.target.composing)return;testData=$event.target.value}}}),_v(&quot; &quot;),_c('button',{on:{&quot;click&quot;:update}},[_v(&quot;update&quot;)])])} _c ---&gt;创建标签 _v ---&gt;创建文本节点 _s ---&gt;字符串序列化 _c: /** * 创建元素 * @param {Object} context miniVue实例 * @param {String} tag 标签 * @param {Object} data 数据 * @param {Array} children 子节点 */ export function createElement(context, tag, data, children) { var vnode; if (!tag) { createEmptyVNode(); } // 兼容不传data的情况, 处理&lt;span&gt;{{a}}&lt;/span&gt;这种dom情况,字符串function为: _c('span', [_v(_s(a))]) if (Array.isArray(data)) { children = data; data = undefined; } if (typeof tag === 'string') { vnode = new VNode(tag, data, children, undefined, undefined, context); } if (vnode !== undefined) { return vnode; } } _v: /** * 创建文本节点 */ export function createTextVNode(val) { return new VNode(undefined, undefined, undefined, String(val)); } 最后 ","link":"https://xiaoai7904.github.io/post/vue-yuan-ma-jie-xi-zi-ji-dong-shou-shi-xian-minivue/"},{"title":"Async Function","content":"Chrome 55 中默认情况下启用异步函数，坦率地讲，它们的作用相当不可思议。 可以利用它们像编写同步代码那样编写基于 Promise 的代码，而且还不会阻塞主线程。 它们可以让异步代码“智商”下降、可读性提高。 异步函数的工作方式是这样的： async function myFirstAsyncFunction() { try { const fulfilledValue = await promise; } catch (rejectedValue) { // … } } 如果在函数定义之前使用了 async 关键字，就可以在函数内使用 await。 当您 await 某个 Promise 时，函数暂停执行，直至该 Promise 产生结果，并且暂停并不会阻塞主线程。 如果 Promise 执行，则会返回值。 如果 Promise 拒绝，则会抛出拒绝的值。 示例 假设我们想获取某个网址并以文本形式记录响应日志。以下是利用 Promise 编写的代码： function logFetch(url) { return fetch(url) .then(response =&gt; response.text()) .then(text =&gt; { console.log(text); }).catch(err =&gt; { console.error('fetch failed', err); }); } 以下是利用异步函数具有相同作用的代码： async function logFetch(url) { try { const response = await fetch(url); console.log(await response.text()); } catch (err) { console.log('fetch failed', err); } } 代码行数虽然相同，但去掉了所有回调。这可以提高代码的可读性，对不太熟悉 Promise 的人而言，帮助就更大了。 异步函数返回值 无论是否使用 await，异步函数都会返回 Promise。该 Promise 解析时返回异步函数返回的任何值，拒绝时返回异步函数抛出的任何值。 // wait ms milliseconds function wait(ms) { return new Promise(r =&gt; setTimeout(r, ms)); } async function hello() { await wait(500); return 'world'; } 调用 hello() 返回的 Promise 会在执行时返回 &quot;world&quot;。 async function foo() { await wait(500); throw Error('bar'); } 其他异步函数语法 我们已经见识了 async function() {}，但 async 关键字还可用于其他函数语法： 箭头函数 // map some URLs to json-promises const jsonPromises = urls.map(async url =&gt; { const response = await fetch(url); return response.json(); }); 对象方法 const storage = { async getAvatar(name) { const cache = await caches.open('avatars'); return cache.match(`/avatars/${name}.jpg`); } }; storage.getAvatar('jaffathecake').then(…); 类方法 class Storage { constructor() { this.cachePromise = caches.open('avatars'); } async getAvatar(name) { const cache = await this.cachePromise; return cache.match(`/avatars/${name}.jpg`); } } const storage = new Storage(); storage.getAvatar('jaffathecake').then(…); ","link":"https://xiaoai7904.github.io/post/async-function/"},{"title":"FromData Blob ArrayBuffe","content":"利用FormData对象,我们可以通过JavaScript用一些键值对来模拟一系列表单控件,我们还可以使用XMLHttpRequest的send()方法来异步的提交这个&quot;表单&quot;,Blob对象表示一个不可变、原始数据的类文件对象,ArrayBuffer对象用来表示通用的、固定长度的原始二进制数据缓冲区 FormData XMLHttpRequest Level 2添加了一个新的接口FormData.利用FormData对象,我们可以通过JavaScript用一些键值对来模拟一系列表单控件,我们还可以使用XMLHttpRequest的send()方法来异步的提交这个&quot;表单&quot;.比起普通的ajax,使用FormData的最大优点就是我们可以异步上传一个二进制文件 上文是MDN\b官方解释,在实际开发中我们可以利用它来进行做上传文件操作,下面代码简单介绍了FormData如何使用 let xhr= new XMLHttpRequest(); let fromdata = new FormData() formdata.append(&quot;token&quot;, 'ddddd-ddd-dd'); xhr.open(&quot;POST&quot;, &quot;xxx.php&quot;); xhr.send(); api append() 给当前FormData对象添加一个键/值对 void append(DOMString name, Blob value, optional DOMString filename) name: 字段名称 value: 字段值.可以是,或者一个字符串,如果全都不是,则该值会被自动转换成字符串 filename[可选] 指定文件的文件名,当value参数被指定为一个Blob对象或者一个File对象时,该文件名会被发送到服务器上,对于Blob对象来说,这个值默认为&quot;blob&quot;) Blob Blob\b即二进制大数据对象,提供相应的接口,其他操作二进制的对象都是建立在Blob基础之上,并继承了\b\b该对象的属性和方法 使用 Blob 创建一个指向类型化数组的URL var typedArray = GetTheTypedArraySomehow(); var blob = new Blob([typedArray], {type: &quot;application/octet-binary&quot;});// 传入一个合适的MIME类型 var url = URL.createObjectURL(blob); // 会产生一个类似blob:d3958f5c-0777-0845-9dcf-2cb28783acaf 这样的URL字符串 // 你可以像使用一个普通URL那样使用它，比如用在img.src上 api Blob.size[只读] Blob对象中所包含数据的大小（字节） Blob.type[只读] 一个字符串，表明该Blob对象所包含数据的MIME类型。如果类型未知，则该值为空字符串 Blob.slice(start,end) 返回一个新的 Blob对象，包含了源 Blob对象中指定范围内的数据 ArrayBuffer ArrayBuffer对象用来表示通用的、固定长度的原始二进制数据缓冲区。ArrayBuffer不能直接操作，而是要通过类型数组对象或 DataView 对象来操作，它们会将缓冲区中的数据表示为特定的格式，并通过这些格式来读写缓冲区的内容 // 创建一个8字节的ArrayBuffer var b = new ArrayBuffer(8); // 创建一个指向b的视图v1，采用Int32类型，开始于默认的字节索引0，直到缓冲区的末尾 var v1 = new Int32Array(b); // 创建一个指向b的视图v2，采用Uint8类型，开始于字节索引2，直到缓冲区的末尾 var v2 = new Uint8Array(b, 2); // 创建一个指向b的视图v3，采用Int16类型，开始于字节索引2，长度为2 var v3 = new Int16Array(b, 2, 2); api new ArrayBuffer(length) length要创建的 ArrayBuffer 的大小，单位为字节,返回一个指定大小的 ArrayBuffer 对象，其内容被初始化为 0 get ArrayBuffer[@@species] 返回 ArrayBuffer 的构造函数 ArrayBuffer.isView(arg) 如果参数是 ArrayBuffer 的视图实例则返回 true，例如 类型数组对象 或 DataView 对象；否则返回 false ArrayBuffer.transfer(oldBuffer [, newByteLength]) 返回一个新的 ArrayBuffer 对象，其内容取自 oldBuffer 中的数据，并且根据 newByteLength 的大小对数据进行截取或补 0 ArrayBuffer.slice() 返回一个新的 ArrayBuffer ，它的内容是这个 ArrayBuffer 的字节副本，从begin（包括），到end（不包括）。如果begin或end是负数，则指的是从数组末尾开始的索引，而不是从头开始 文章参考 ArrayBuffer-MDN Blob-MDN FormData-MDN ","link":"https://xiaoai7904.github.io/post/fromdata-blob-arraybuffe/"},{"title":"移动端开中遇到的问题整理","content":"在日常开发中移动端遇到的问题进行一个整理，方便后面查看 input文本框宽度设置100%时越界的解决方法 在开发H5页面时碰到这么一个坑，input文本框的宽度设置为100%时，其实际宽度居然会超出父元素，然而在PC上一切正常 &amp;-search__ipt { width: 100%; height: 60px; background-color: #eaeaea; border:0; outline: 0; border-radius: 30px; color: #b0b0b0; text-align: center; font-size: 20px; } 解决办法: 添加box-sizing: border-box属性即可解决 产生原因: W3C标准定义：content宽度就是实际定义的宽度，width你定义多款conten就是多宽传统的,IE下定义：content包括：width、padding、border，也就是content=width+padding+border 弹出遮罩滚动条事件穿透 // 方法一: document.body.addEventListener('touchmove', function(e) { e.preventDefault(); }, false); //方法二: .scroll { position: fixed; width: 100%; } var scroll = (function (className) { var scrollTop; return { afterOpen: function () { scrollTop = document.scrollingElement.scrollTop || document.body.scrollTop; document.body.classList.add(className); document.body.style.top = -scrollTop + 'px'; }, beforeClose: function () { document.body.classList.remove(className); document.scrollingElement.scrollTop = scrollTop; document.body.scrollTop = scrollTop; } }; })('scroll'); IOS\b滚动条卡顿问题 以下代码可解决这种卡顿的问题：-webkit-overflow-scrolling: touch;，是因为这行代码启用了硬件加速特性，所以滑动很流畅 推荐一个插件iScroll 微信浏览器用户调整字体大小后页面矬了，怎么阻止用户调整 //以下代码可使Android机页面不再受用户字体缩放强制改变大小，但是会有1S左右延时，期间可以考虑loading来处理 if (typeof(WeixinJSBridge) == &quot;undefined&quot;) { document.addEventListener(&quot;WeixinJSBridgeReady&quot;, function (e) { setTimeout(function(){ WeixinJSBridge.invoke('setFontSizeCallback', { 'fontSize':0}, function(res){ alert(JSON.stringify(res)); }) }, 0) }); }else{ setTimeout(function(){ WeixinJSBridge.invoke('setFontSizeCallback', { 'fontSize':0}, function(res){ alert(JSON.stringify(res)); }) }, 0) } //IOS下可使用 -webkit-text-size-adjust禁止用户调整字体大小 body { -webkit-text-size-adjust:100%!important; } //最好的解决方案：最好使用rem或百分比布局 作者：我是大师兄啊 链接：https://www.jianshu.com/p/220b56eb20e9 來源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。 屏幕旋转的事件和样式 function orientInit(){ var orientChk = document.documentElement.clientWidth &gt; document.documentElement.clientHeight?'landscape':'portrait'; if(orientChk =='lapdscape'){ //这里是横屏下需要执行的事件 }else{ //这里是竖屏下需要执行的事件 } } orientInit(); window.addEventListener('onorientationchange' in window?'orientationchange':'resize', function(){ setTimeout(orientInit, 100); },false) //CSS处理 //竖屏时样式 @media all and (orientation:portrait){ } //横屏时样式 @media all and (orientation:landscape){ } 作者：我是大师兄啊 链接：https://www.jianshu.com/p/220b56eb20e9 來源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。 audio元素和video元素在ios和andriod中无法自动播放 &lt;audio src=&quot;music/bg.mp3&quot; autoplay loop controls&gt;你的浏览器还不支持哦&lt;/audio&gt; &lt;audio controls=&quot;controls&quot;&gt; &lt;source src=&quot;music/bg.ogg&quot; type=&quot;audio/ogg&quot;&gt;&lt;/source&gt; &lt;source src=&quot;music/bg.mp3&quot; type=&quot;audio/mpeg&quot;&gt;&lt;/source&gt; 优先播放音乐bg.ogg，不支持在播放bg.mp3 &lt;/audio&gt; //JS绑定自动播放（操作window时，播放音乐） $(window).one('touchstart', function(){ music.play(); }) //微信下兼容处理 document.addEventListener(&quot;WeixinJSBridgeReady&quot;, function () { music.play(); }, false); //小结 //1.audio元素的autoplay属性在IOS及Android上无法使用，在PC端正常 //2.audio元素没有设置controls时，在IOS及Android会占据空间大小，而在PC端Chrome是不会占据任何空间 作者：我是大师兄啊 链接：https://www.jianshu.com/p/220b56eb20e9 來源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。 重力感应事件 // 运用HTML5的deviceMotion，调用重力感应事件 if(window.DeviceMotionEvent){ document.addEventListener('devicemotion', deviceMotionHandler, false) } var speed = 30; var x = y = z = lastX = lastY = lastZ = 0; function deviceMotionHandler(eventData){ var acceleration = event.accelerationIncludingGravity; x = acceleration.x; y = acceleration.y; z = acceleration.z; if(Math.abs(x-lastX)&gt;speed || Math.abs(y-lastY)&gt;speed || Math.abs(z-lastZ)&gt;speed ){ //这里是摇动后要执行的方法 yaoAfter(); } lastX = x; lastY = y; lastZ = z; } function yaoAfter(){ //do something } 开启硬件加速 .css { -webkit-transform: translate3d(0,0,0); -moz-transform: translate3d(0,0,0); -ms-transform: translate3d(0,0,0); transform: translate3d(0,0,0); } 消除transition闪屏 .css { -webkit-transform-style: preserve-3d; -webkit-backface-visibility: hidden; -webkit-perspective: 1000; } 持续更新中... ","link":"https://xiaoai7904.github.io/post/yi-dong-duan-kai-zhong-yu-dao-de-wen-ti-zheng-li/"},{"title":"js原型继承五条基本原","content":"js中的原型继承，遵守5个基本原则： 所有的数据都是对象 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它 对象会记住它的原型 如果对象无法响应某个请求，它会把这个请求委托给它自己的原型 接下来我们将详细讲解这个5个基本原则..... 所有的数据都是对象 js在设计的时候引入了java两套类型机制：基本类型和引用类型 基本类型包括：undefined、number、boolean、string、function、object 我们不能说js中所有的数据都是对象，但是可以说绝大多数的数据都是对象，那么相信在js中也一定会存在一个根对象(Object.prototype) 在js中根对象(Object.prototype)是一个空的对象，我们遇到的每一个对象都是从Object.prototype对象克隆而来，Object.prototype对象就是它们的原型。 var obj_1 = new Object(); var obj_2 = {}; //通过Object.getPrototypeOf来查看它们的原型 console.log(Object.getPrototypeOf(obj_1) === Object.prototype); // true console.log(Object.getPrototypeOf(obj_2) === Object.prototype); // true 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它 在js中我们并不需要关心克隆的细节，因为这些操作浏览器引擎内部已经实现了，我们只需要显式地调用var obj = new Object()或者var obj = {}，引擎会从Object.prototype上克隆一个对象出来。 我们也可以通过new操作符来创建一个对象 function Person(name){ this.name= name; }; Person.prototype.getName = function(){ return this.name; } var r = new Person('anjie'); // 通过new操作符得到一个对象 console.log(r.name);//anjie console.log(r.getName());//anjie console.log(Object.getPrototypeOf(r) === Person.prototype); // true 我们通过new得到的对象具体做了什么？ 要创建 Person 的新实例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下 4 个步骤： 创建一个新对象； 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）； 执行构造函数中的代码（为这个新对象添加属性； 返回新对象； new操作符具体做了3件事 // 创建空对象 var r = {}; //将这个空对象的__proto__成员指向了Person函数对象prototype成员对象 r.__proto__ = Person.prototype //将Person函数对象的this指针替换成r，然后再调用Person函数,给r添加属性和方法 Person.call(r) 模仿new操作符 function Person(name){ this.name = name; } Person.prototype.getName = function(){ return this.name; } var simulationNew = function(){ var obj = new Object(); // 从Objecet.prototype克隆一个对象 var Constructor = [].shift.call(arguments); // 获取外部参数 obj.__proto__ = Constructor.prototype;//指向正确的原型 var newObj = Constructor.apply(obj,arguments); //借用外部传入的构造器给obj设置属性 return typeof newObj === 'object' ? newObj : obj; //确保返回的永远是一个对象 } var a = simulationNew(Person,'anjie'); console.log(a.name);//anjie console.log(a.getName());//anjie console.log(Object.getPrototypeOf(a) === Person.prototype); // true 对象会记住它的原型 js给对象提供了一个名为__proto__的隐藏属性，某个对象的__proto__属性默认会指向它的构造器的原型对象，即{Constructor.prototype},在一些浏览器中，__proto__被公开出来了(Chrome/Firefox) var a = new Object(); console.log(a.__proto__ === Object.prototype); //true __proto__就是对象跟对象构造器的原型联系起来的桥梁，正因为对象通过__proto__来记住的构造器的原型，我们上面模拟new操作符需要手动的给obj对象设置正确的__proto__指向 如果对象无法响应某个请求，它会把这个请求委托给它自己的原型 在js中，每个对象都是通过Object.prototype克隆出来的，如果是这样的话我们只能得到单一的继承关系，即每个对象都是继承自Object.prototype对象，这样的对象显然是非常受限的。 js对象最初都是由Object.prototype克隆而来，但是对象构造器的原型并不仅限于Object.prototype上，而是可以动态指向其他对象，这样一来，但对象a需要借用b对象的能力时，可以选择性的把对象a的原型指向对象b，从而达到继承的效果。 下面的代码是我们常用的原型继承方式： var obj = {name:'anjie'}; var A = function(){} A.prototype = obj; var a = new A(); console.log(a.name);//anjie 上面的代码引擎内部做了什么？ 遍历对象a中的所有属性，但是没有name这个属性 查找name属性的这个请求委托对象a的构造器的原型，它被a.__proto__记录着并且指向A.prototype,而A.prototype被设置为对象obj 在对象obj中找到name属性，并返回它的值 当我们期望得到一个类继承自另一个类时我们通常会使用下面这段代码： var A = function(){}; A.prototype = { name:'anjie' } var B = function(){} B.prototype = new A(); var b = new B(); console.log(b.name);//anjie 上面的代码引擎内部做了什么？ 遍历对象a中的所有属性，但是没有name这个属性 查找name属性的这个请求委托对象b的构造器的原型，它被b.__proto__记录着并且指向B.prototype,而B.prototype被设置为通过new A()创建出来的对象 在该对象中依然没有找到name属性，于是请求将继续委托给这个对象构造器的原型A.prototype 在A.prototype中找到name属性，并返回它的值 如果A.prototype中还没有知道name属性，请求会被传递给A.prototype的原型Object.prototype，如果没有name属性，会继续传递给Object.prototype的原型，Object.prototype的原型是null,所以会返回undefined ES6的中带来了新的Class语法，让js看起来更加想一门基于类的语言，其实背后还是通过原型机制来实现的。 Class Person{ constructor(name){ this.name = name; }, getName(){ return this.name } } Class manPerson extends Person { constructor(name){ super(name); } } var a = new manPerson('anjie'); console.log(a.getName());//anjie 总结就写到这里了，本文简单介绍了js中原型继承的机制，希望通过学习的我们的学习总结笔记让大家也有收获，如果有什么不对的地方，望大家指点出来，我们共同学习。 ","link":"https://xiaoai7904.github.io/post/js-yuan-xing-ji-cheng-wu-tiao-ji-ben-yuan/"},{"title":"js设计模式-单例模式","content":"单例模式是一种常见的模式，有一些对象我们往往只需要一个，比如线程池、全局缓存、浏览器中的window对象等。在js开发中，单例模式的用途同样非常广泛...... 单例模式的定义 定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 实现单例模式 原理：用一个变量来保存当前是否已经为某个类创建对象，如果创建了就直接返回该对象，反之就重新实例化 var Fn = function(name){ this.name = name; } Fn.prototype.getName = function(){ console.log(this.name); } Fn.getInstance = (function(){ var instance = null; return function(name){ if(!instance){ instance = new Fn(name); } return instance; } })(); var a = Fn.getInstance('xxx'); var b = Fn.getInstance('ooo'); console.log(a === b);//true 透明的单例模式 我们创建一个CreateDiv单例类来负责在页面中创建唯一的div节点，实现一个**‘透明’**的单例类，用户从这个类中创建对象的时候，可以像使用任何普通类一样。 var CreateDiv = (function(){ var instance; var CreateDiv = function(html){ if(instance){ return instance; } this.html= html; this.init(); return instance = this; }; CreateDiv.prototype.init = function(){ var div = $('&lt;div&gt;&lt;/div&gt;'); div.html(this.html); $(body).append(div); } return CreateDiv; })() var a = new CreateDiv('one'); var b = new CreateDiv('two'); console.log(a === b); //true 上面的代码实现了**透明**单例，但是也有它的缺点，上面我们使用了自执行函数和闭包，并且让这个匿名函数返回真正的构造函数，这样增加了一些程序的复杂度。 如果某天我们需要利用这个类，在页面上创建很多个div，既要让这个单例类变成一个普通的可以产生多个实例，那我们就需要修改CreateDiv构造函数，把控制创建唯一对象的那段代码删除掉，这样就会刚给我带来一些不必要的麻烦，所有我们利用另外一种方式去实现，这种方式叫着**代理模式**,后面的笔记中我会详细介绍**代理模式**的具体实习方式 利用代理模式实现单例模式 我们把上面的透明单例代码中间创建div部分代码移除出去，使他成为一个普通的创建DIV类 //创建div类 var CreateDiv = function(html){ this.html = html; this.init(); } CreateDiv.prototype = function(){ var div = $('&lt;div&gt;&lt;/div&gt;'); div.html(this.html); $('body').append(div); } //代理类 var ProxySingleton = (function(){ var instance; return function(){ if(!instance){ instance = new CreateDiv(html); } return instance; } })() //测试 var a = new ProxySingleton('one'); var b = new ProxySingleton('two'); console.log(a === b );//true 通过引入代理类的方式，我们也实现了单例模式，我们把负责管理单例的逻辑移到代理类**ProxySingleton**中，**CreateDiv**就变成一个普通类，它更**ProxySingleton**组合起来就可以实现单例模式的效果，这样的代码会更叫好维护。 JavaScript中的单例模式 上面提到的创建单例模式，更多的是接近面向对象语言中的实现，单例对象从**‘类’**创建而来，在类为中心得语言中，这是很自然的做法。 在JavaScript中，其实是一门无类语言，没有类这个概念，在JS中创建单例模式方法很简单，我们只需要创建一个唯一的类。 全局变量不是单例模式，但是在js开发中，我们经常把全局变量当成单例模式来使用 我们在js开发中有必要减少全局变量的使用，如果使用了也要把它的污染降到最低，以下两种方式就是降低全局变量带来的命名污染 使用命名空间 使用对象字面量的方式来创建： var name = { a:function(){ console.log('1'); }, b:function(){ console.log('2'); } }; 使用动态创建命名空间 var My = {}; My.name = function(name){ var parts = name.split('.'); var current = My; for(var i in parts){ if(!current[parts[i]]){ current[parts[i]] = {}; } current = current[parts[i]]; } } My.name = ('init'); My.name = ('dom.style'); //上面创建结果等价于： var My = { init:{}, dom:{ style:{} } }; 使用闭包封装私有变量 var user = (function(){ var __name = 'anjie', __age = 25, return { getUserInfo:function(){ return __name + '-' + __age; } } })(); 我们使用下划线来约定私有变量__name和__age,他们被封装在闭包产生的作用域中，外部是访问不到这两个变量的，这样就避免了对全局的命令污染。 通用单例模式 var getSingle = function(fn){ var result; return function(){ return result || (result = fn.apply(this,arguments)); } } //实例 var createDiv = function(){ var div = $('&lt;div&gt;&lt;/div&gt;'); div.html('这个是测试div'); div.css('display','none'); $('body').append(div); return div; } var createSingleLoginLayer = getSingle(createDiv); $('loginBtn').on('click',function(){ var loginLayer = createSingleLoginLayer(); loginLayer.css('display','block'); }) 上面代码是一个通用的单例模式，我们在日常开发中可以直接利用这段代码来实现单例模式。 以上代码借鉴于《JavaScript设计模式与开发实践》 -- 曾探,这本书对设计模式进行的详细的介绍，推荐大家学习 ","link":"https://xiaoai7904.github.io/post/js-she-ji-mo-shi-dan-li-mo-shi/"},{"title":"TypeScript入门教程(十四) - 装饰器","content":"随着TypeScript和ES6里引入了类，在一些场景下我们需要额外的特性来支持标注或修改类及其成员。 装饰器（Decorators）为我们在类的声明及成员上通过元编程语法添加标注提供了一种方式。 Javascript里的装饰器目前处在建议征集的第二阶段，但在TypeScript里已做为一项实验性特性予以支持 介绍 若要启用实验性的装饰器特性，你必须在命令行或tsconfig.json里启用experimentalDecorators编译器选项 命令行: tsc --target ES5 --experimentalDecorators tsconfig.json: { &quot;compilerOptions&quot;: { &quot;target&quot;: &quot;ES5&quot;, &quot;experimentalDecorators&quot;: true } } 装饰器 装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上。 装饰器使用@expression这种形式，expression求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入 方法装饰器 方法装饰器声明在一个方法的声明之前（紧靠着方法声明）。 它会被应用到方法的 属性描述符上，可以用来监视，修改或者替换方法定义。 方法装饰器不能用在声明文件(· .d.ts)，重载或者任何外部上下文（比如declare的类）中 方法装饰器表达式会在运行时当作函数被调用，传入下列3个参数 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象 成员的名字 成员的属性描述符 class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } @enumerable(false) greet() { return &quot;Hello, &quot; + this.greeting; } } function enumerable(value: boolean) { return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) { descriptor.enumerable = value; }; } 访问器装饰器 访问器装饰器声明在一个访问器的声明之前（紧靠着访问器声明）。 访问器装饰器应用于访问器的 属性描述符并且可以用来监视，修改或替换一个访问器的定义。 访问器装饰器不能用在声明文件中（.d.ts），或者任何外部上下文（比如declare的类）里 TypeScript不允许同时装饰一个成员的get和set访问器。取而代之的是，一个成员的所有装饰的必须应用在文档顺序的第一个访问器上。这是因为，在装饰器应用于一个属性描述符时，它联合了get和set访问器，而不是分开声明的 访问器装饰器表达式会在运行时当作函数被调用，传入下列3个参数： 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象 成员的名字 成员的属性描述符 class Point { private _x: number; private _y: number; constructor(x: number, y: number) { this._x = x; this._y = y; } @configurable(false) get x() { return this._x; } @configurable(false) get y() { return this._y; } } function configurable(value: boolean) { return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) { descriptor.configurable = value; }; } 属性装饰器 属性装饰器声明在一个属性声明之前（紧靠着属性声明）。 属性装饰器不能用在声明文件中（.d.ts），或者任何外部上下文（比如declare的类）里 属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数： 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象 成员的名字 class Greeter { @format(&quot;Hello, %s&quot;) greeting: string; constructor(message: string) { this.greeting = message; } greet() { let formatString = getFormat(this, &quot;greeting&quot;); return formatString.replace(&quot;%s&quot;, this.greeting); } } import &quot;reflect-metadata&quot;; const formatMetadataKey = Symbol(&quot;format&quot;); function format(formatString: string) { return Reflect.metadata(formatMetadataKey, formatString); } function getFormat(target: any, propertyKey: string) { return Reflect.getMetadata(formatMetadataKey, target, propertyKey); } 这个@format(&quot;Hello, %s&quot;)装饰器是个装饰器工厂。 当@format(&quot;Hello, %s&quot;)被调用时，它添加一条这个属性的元数据，通过reflect-metadata库里的Reflect.metadata函数。 当 getFormat被调用时，它读取格式的元数据 这个例子需要使用reflect-metadata库。 查看 元数据了解reflect-metadata库更详细的信息。 参数装饰器 参数装饰器声明在一个参数声明之前（紧靠着参数声明）。 参数装饰器应用于类构造函数或方法声明。 参数装饰器不能用在声明文件（.d.ts），重载或其它外部上下文（比如declare的类）里 参数装饰器表达式会在运行时当作函数被调用，传入下列3个参数： 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象 成员的名字 参数在函数参数列表中的索引 class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } @validate greet(@required name: string) { return &quot;Hello &quot; + name + &quot;, &quot; + this.greeting; } } import &quot;reflect-metadata&quot;; const requiredMetadataKey = Symbol(&quot;required&quot;); function required(target: Object, propertyKey: string | symbol, parameterIndex: number) { let existingRequiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || []; existingRequiredParameters.push(parameterIndex); Reflect.defineMetadata(requiredMetadataKey, existingRequiredParameters, target, propertyKey); } function validate(target: any, propertyName: string, descriptor: TypedPropertyDescriptor&lt;Function&gt;) { let method = descriptor.value; descriptor.value = function () { let requiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyName); if (requiredParameters) { for (let parameterIndex of requiredParameters) { if (parameterIndex &gt;= arguments.length || arguments[parameterIndex] === undefined) { throw new Error(&quot;Missing required argument.&quot;); } } } return method.apply(this, arguments); } } @required装饰器添加了元数据实体把参数标记为必需的。 @validate装饰器把greet方法包裹在一个函数里在调用原先的函数前验证函数参数 上面我们介绍了TypeScript的装饰器，到此Typescript入门教程完结 文章参考TypeScript中文网 ","link":"https://xiaoai7904.github.io/post/typescript-ru-men-jiao-cheng-shi-si-zhuang-shi-qi/"},{"title":"TypeScript入门教程(十三) - 命名空间","content":"描述了如何在TypeScript里使用命名空间（之前叫做“内部模块”）来组织你的代码。任何使用module关键字来声明一个内部模块的地方都应该使用namespace关键字来替换 命名空间 使用命名空间不用担心与其它对象产生命名冲突 namespace Validation { export interface StringValidator { isAcceptable(s: string): boolean; } const lettersRegexp = /^[A-Za-z]+$/; const numberRegexp = /^[0-9]+$/; export class LettersOnlyValidator implements StringValidator { isAcceptable(s: string) { return lettersRegexp.test(s); } } export class ZipCodeValidator implements StringValidator { isAcceptable(s: string) { return s.length === 5 &amp;&amp; numberRegexp.test(s); } } } // Some samples to try let strings = [&quot;Hello&quot;, &quot;98052&quot;, &quot;101&quot;]; // Validators to use let validators: { [s: string]: Validation.StringValidator; } = {}; validators[&quot;ZIP code&quot;] = new Validation.ZipCodeValidator(); validators[&quot;Letters only&quot;] = new Validation.LettersOnlyValidator(); // Show whether each string passed each validator for (let s of strings) { for (let name in validators) { console.log(`&quot;${ s }&quot; - ${ validators[name].isAcceptable(s) ? &quot;matches&quot; : &quot;does not match&quot; } ${ name }`); } } 别名 另一种简化命名空间操作的方法是使用import q = x.y.z给常用的对象起一个短的名字。 不要与用来加载模块的 import x = require('name')语法弄混了，这里的语法是为指定的符号创建一个别名。 你可以用这种方法为任意标识符创建别名，也包括导入的模块中的对象 namespace Shapes { export namespace Polygons { export class Triangle { } export class Square { } } } import polygons = Shapes.Polygons; let sq = new polygons.Square(); // Same as &quot;new Shapes.Polygons.Square()&quot; 外部命名空间 流行的程序库D3在全局对象d3里定义它的功能。 因为这个库通过一个 标签加载（不是通过模块加载器），它的声明文件使用内部模块来定义它的类型。 为了让TypeScript编译器识别它的类型，我们使用外部命名空间声明。 比如，我们可以像下面这样写 declare namespace D3 { export interface Selectors { select: { (selector: string): Selection; (element: EventTarget): Selection; }; } export interface Event { x: number; y: number; } export interface Base extends Selectors { event: Event; } } declare var d3: D3.Base; 上面我们介绍了TypeScript的命名空间，第十四节我们将介绍装饰器 文章参考TypeScript中文网 ","link":"https://xiaoai7904.github.io/post/typescript-ru-men-jiao-cheng-shi-san-ming-ming-kong-jian/"},{"title":"TypeScript入门教程(十二) - 模块","content":"模块是在自身的作用域执行,也就是说在一个模块里面声明的变量,类,函数都是在模块中可见,模块外面是不可见的，除非使用export导出,其他模块使用import引入就可以使用其他模块导出的变量,类,函数等 导出 任何声明(变量,函数,类,类别别名或接口)都能够通过添加export关键字来导出 export const a = '112' export interface Styles { width: string height: string } export function fn1() {} export class Fn {} export {Fn as fn} // 导出的部分重命名 export * from '文件路径' export default class Styles {} // 默认导出 导入 模块的导入操作与导出一样简单。 可以使用以下 import形式之一来导入其它模块中的导出内容 import { Fn } from '引入的文件路径' import {Fn as fn } from '引入的文件路径' // 导入内容重命名 import * as styles from '引入的文件路径' // 将整个模块导入到一个变量 import '引入的文件路径' // 引入文件 import style from '引入的文件路径' // 引入默认导出文件 export = 和 import = require() CommonJS和AMD的环境里都有一个exports变量，这个变量包含了一个模块的所有导出内容。 CommonJS和AMD的exports都可以被赋值为一个对象, 这种情况下其作用就类似于es6语法里的默认导出，即export default语法了。虽然作用相似，但是export default语法并不能兼容CommonJS和AMD的exports。 为了支持CommonJS和AMD的exports, TypeScript提供了export =语法。 export =语法定义一个模块的导出对象。 这里的对象一词指的是类，接口，命名空间，函数或枚举。 若使用export =导出一个模块，则必须使用TypeScript的特定语法import module = require(&quot;module&quot;)来导入此模块 class Styles { constructor(public styles: object) getStyle(key: string): number | string { return this.styles[key] } } export = Styles // 使用方式如下 import Styles = require('文件路径') let s = new Styles({ width : 200 }) s.getStyle('width') // 200 上面我们介绍了TypeScript的模块，第十三节我们将介绍命名空间 文章参考TypeScript中文网 ","link":"https://xiaoai7904.github.io/post/typescript-ru-men-jiao-cheng-shi-er-mo-kuai/"},{"title":"TypeScript入门教程(十一) - 迭代器和生成器","content":"for..of 语句 let someArray = [1, &quot;string&quot;, false]; for (let entry of someArray) { console.log(entry); // 1, &quot;string&quot;, false } for..in 语句 let list = [4, 5, 6]; for (let i in list) { console.log(i); // &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, } for (let i of list) { console.log(i); // &quot;4&quot;, &quot;5&quot;, &quot;6&quot; } 区别 for..of和for..in均可迭代一个列表；但是用于迭代的值却不同，for..in迭代的是对象的 键 的列表，而for..of则迭代对象的键对应的值，for..in可以操作任何对象；它提供了查看对象属性的一种方法。 但是 for..of关注于迭代对象的值 这节的内容比较简单,所以只是写了几段代码来进行解释 上面我们介绍了TypeScript的迭代器和生成器，第十二节我们将介绍模块 文章参考TypeScript中文网 ","link":"https://xiaoai7904.github.io/post/typescript-ru-men-jiao-cheng-shi-yi-die-dai-qi-he-sheng-cheng-qi/"},{"title":"TypeScript入门教程(十) - Symbols","content":"自ECMAScript 2015(ES6)起，symbol成为了一种新的原生类型，就像number和string一样 介绍 symbol类型的值是通过Symbol构造函数创建的 let sym1 = Symbol(); let sym2 = Symbol(&quot;key&quot;); // 可选的字符串key 需要\b注意的\b是symbol是唯一的 像字符串一样，symbols也可以被用做对象属性的键,也可以计算出的属性名声明相结合来声明对象的属性和类成员 let sym = Symbol(); let obj = { [sym]: &quot;value&quot; }; console.log(obj[sym]); // &quot;value&quot; const getClassNameSymbol = Symbol(); class C { [getClassNameSymbol](){ return &quot;C&quot;; } } let c = new C(); let className = c[getClassNameSymbol](); // &quot;C&quot; \b更多Symbols\b用法建议查看阮一峰ES6里面写的很详细 上面我们介绍了TypeScript的Symbols，第十一节我们将介绍迭代器和生成器 文章参考TypeScript中文网 ","link":"https://xiaoai7904.github.io/post/typescript-ru-men-jiao-cheng-shi-symbols/"},{"title":"TypeScript入门教程(九) - 高级类型","content":"高级\b类型(交叉类型,联合类型,类型保护与区分类型,类型别名,字符串字面量类型,数字字面量类型,枚举成员类型,多态的this类型,索引类型,映射类型)\b我们会对10种进行详情介绍 交叉类型(Intersection Types) 交叉类型是将多个类型合并到\b一个类型\b\b,比如:Fn1 &amp; Fn2 &amp; Fn3同时是Fn1和Fn2和Fn3,这个类型的对象同时拥有这三种类型的成员。 来看一个混入(mixins)的例子: function extend&lt;T, U&gt;(first: T, second: U): T &amp; U { let result = &lt;T &amp; U&gt;{}; for (let id in first) { (&lt;any&gt;result)[id] = (&lt;any&gt;first)[id]; } for (let id in second) { if (!result.hasOwnProperty(id)) { (&lt;any&gt;result)[id] = (&lt;any&gt;second)[id]; } } return result; } interface FnInterface { getName(): string; } class Fn1 { constructor(public name: string) { } } class Fn2 implements FnInterface { getName() { console.log('getName') } } let f = extend(new Fn1(&quot;mickey&quot;), new Fn2()); let n = f.name; // mickey f.getName(); // getName 联合类型(Union Types) 联合类型表示一个值可以是几种类型之,用竖线 | 分隔每个类型 function setWidth(dom: any, width: string | number): void { dom.style.width = width } 类型保护与区分类型(Type Guards and Differentiating Type) let pet = getSmallPet(); // 每一个成员访问都会报错 if (pet.swim) { pet.swim(); } else if (pet.fly) { pet.fly(); } 修改上面的代码 let pet = getSmallPet(); if ((&lt;Fish&gt;pet).swim) { (&lt;Fish&gt;pet).swim(); } else { (&lt;Bird&gt;pet).fly(); } 用户自定义的类型保护 TypeScript里的 类型保护机制让它成为了现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。 要定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个 类型谓词 function isFish(pet: Fish | Bird): pet is Fish { return (&lt;Fish&gt;pet).swim !== undefined; } typeof类型保护 这些typeof类型保护只有两种形式能被识别：typeof v === &quot;typename&quot;和 typeof v !== &quot;typename&quot;， &quot;typename&quot;必须是 &quot;number&quot;， &quot;string&quot;， &quot;boolean&quot;或 &quot;symbol&quot;。 但是TypeScript并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护 instanceof类型保护 instanceof类型保护是通过构造函数来细化类型的一种方式 instanceof的右侧要求是一个构造函数，TypeScript将细化为: 此构造函数的 prototype属性的类型，如果它的类型不为 any的话 构造签名所返回的类型的联合 类型别名 类型别名就是给\b类型起一个新的名字,起别名不会新建一个类型，只是用新的名字来引用那个类型 type Name = string; type NameResolver = () =&gt; string; type NameOrResolver = Name | NameResolver; function getName(n: NameOrResolver): Name { if (typeof n === 'string') { return n; } else { return n(); } } 类型别名也可以是泛型 type Container&lt;T&gt; = { value: T }; type Tree&lt;T&gt; = { value: T; left: Tree&lt;T&gt;; right: Tree&lt;T&gt;; } 类型\b别名不能出现在声明\b右侧的任何地方 type Yikes = Array&lt;Yikes&gt;; // error 字符串字面量类型 字符串字面量类型允许你指定字符串必须的固定值。 在实际应用中，字符串字面量类型可以与联合类型，类型保护和类型别名很好的配合。 通过结合使用这些特性，你可以实现类似枚举类型的字符串 type Easing = &quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;; class UIElement { animate(dx: number, dy: number, easing: Easing) { if (easing === &quot;ease-in&quot;) { // ... } else if (easing === &quot;ease-out&quot;) { } else if (easing === &quot;ease-in-out&quot;) { } else { } } } let button = new UIElement(); button.animate(0, 0, &quot;ease-in&quot;); button.animate(0, 0, &quot;uneasy&quot;); // error: &quot;uneasy&quot; is not allowed here 字符串字面量类型还可以用于区分函数重载 function createElement(tagName: &quot;img&quot;): HTMLImageElement; function createElement(tagName: &quot;input&quot;): HTMLInputElement; // ... more overloads ... function createElement(tagName: string): Element { // ... code goes here ... } 数字字面量类型 function rollDie(): 1 | 2 | 3 | 4 | 5 | 6 { // ... } 多态的this类型 多态的 this类型表示的是某个包含类或接口的 子类型。 这被称做 F-bounded多态性。 它能很容易的表现连贯接口间的继承，比如。 在计算器的例子里，在每个操作之后都返回 this类型: class BasicCalculator { public constructor(protected value: number = 0) { } public currentValue(): number { return this.value; } public add(operand: number): this { this.value += operand; return this; } public multiply(operand: number): this { this.value *= operand; return this; } // ... other operations go here ... } let v = new BasicCalculator(2) .multiply(5) .add(1) .currentValue(); 由于这个类使用了 this类型，你可以继承它，新的类可以直接使用之前的方法，不需要做任何的改变 class ScientificCalculator extends BasicCalculator { public constructor(value = 0) { super(value); } public sin() { this.value = Math.sin(this.value); return this; } } let v = new ScientificCalculator(2) .multiply(5) .sin() .add(1) .currentValue(); 索引类型(Index types) 使用索引类型，编译器就能够检查使用了动态属性名的代码 function pluck(o, names) { return names.map(n =&gt; o[n]); } function pluck&lt;T, K extends keyof T&gt;(o: T, names: K[]): T[K][] { return names.map(n =&gt; o[n]); } interface Person { name: string; age: number; } let person: Person = { name: 'Jarid', age: 35 }; let strings: string[] = pluck(person, ['name']); // ok, string[] 上面代码引入了新的类型操作符keyof T,索引类型查询操作符和T[K],索引访问操作符 let personProps: keyof Person; // 'name' | 'age' 上面代码可以同通过let personProps: 'name' | 'age'替换,但是如果添加了新的属性到Person里面keyof Person会\b自动添加新增的属性,因此在\b使用前不清楚出现的属性名,就可以这样使用 function getProperty&lt;T, K extends keyof T&gt;(o: T, name: K): T[K] { return o[name]; // o[name] is of type T[K] } getProperty里的o: T和name: K，意味着o[name]: T[K]。 当你返回T[K]的结果，编译器会实例化键的真实类型，因此 getProperty的返回值类型会随着你需要的属性改变 keyof和T[K]与字符串索引签名进行交互。 如果你有一个带有字符串索引签名的类型，那么keyof T会是string。 并且T[string]为索引签名的类型 interface Map&lt;T&gt; { [key: string]: T; } let keys: keyof Map&lt;number&gt;; // string let value: Map&lt;number&gt;['foo']; // number 映射类型 TypeScript提供了从旧类型中创建新类型的一种方式 — 映射类型 type Readonly&lt;T&gt; = { readonly [P in keyof T]: T[P]; } type Partial&lt;T&gt; = { [P in keyof T]?: T[P]; } 使用如下: type PersonPartial = Partial&lt;Person&gt;; type ReadonlyPerson = Readonly&lt;Person&gt;; 它的语法与索引签名的语法类型，内部使用了 for .. in。 具有三个部分 类型变量 K，它会依次绑定到每个属性 字符串字面量联合的 Keys，它包含了要迭代的属性名的集合 属性的结果类型 type NullablePerson = { [P in keyof Person]: Person[P] | null } type PartialPerson = { [P in keyof Person]?: Person[P] } type Nullable&lt;T&gt; = { [P in keyof T]: T[P] | null } type Partial&lt;T&gt; = { [P in keyof T]?: T[P] } 上面代码是真正应用中使用到的 \b\b上面介绍了高级类型种的10种类型,这也是日常我们会用到的 上面我们介绍了TypeScript的高级类型，第十节我们将介绍Symbols 文章参考TypeScript中文网 ","link":"https://xiaoai7904.github.io/post/typescript-ru-men-jiao-cheng-jiu-gao-ji-lei-xing/"},{"title":"TypeScript入门教程(八) - 类型推断","content":"typescript类型是在那里如何被推断的？ 介绍 我们声明变量时不指定变量类型，TypeScript会进行类型推断来帮助我们提供类型 let a = 1 let b = 'string' 上面代码中变量a,b分别会被类型推断推断为number和string 但是有的情况类型推断无法自动推断出类型,下面小节会介绍 最佳通用类型 当需要\b从几个表达式中推断类型的时候，会使用这些表达式的类型来推断一个最适合的通用类型 let a = [0, 1, null] 为了推断变量a的类型，我们必须考虑所有元素的类型。 这里有两种选择： number和null。 计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型 有时候候选类型共享相同的通用类型,但是却没有一个类型能做为所有候选类型的类型 let style = [new Width(), new Height(), new Color()] 上面代码我们想style被推断为Style[]类型,但是数组没有对象时Style\b类型,因此不能推断出结果，修改一下代码如下: let style: Style[] = [new Width(), new Height(), new Color()] 如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型(Width | Height| color)[] 上下文类型 window.onmousedown = function(mouseEvent) { console.log(mouseEvent.button); //&lt;- Error } TypeScript类型检查器使用Window.onmousedown函数的类型来推断右边函数表达式的类型,如果函数表达式不是在上下文类型的位置， mouseEvent参数的类型需要指定为any，这样也不会报错了 window.onmousedown = function(mouseEvent: any) { console.log(mouseEvent.button); //ok } 上面我们介绍了TypeScript的类型推断，第九节我们将介绍高级类型 文章参考TypeScript中文网 ","link":"https://xiaoai7904.github.io/post/typescript-ru-men-jiao-cheng-ba-lei-xing-tui-duan/"},{"title":"TypeScript入门教程(七) - 枚","content":"使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript支持数字的和基于字符串的枚举 数字枚举 enum des { top = 1, right, bottom, left } 上面代码定义了数字枚举,top使用初始化值为1,其余的成员就会从1开始自动增长 我们也可以不制定初始化值，那么top就会是0，其他成员就会从0开始增长 字符串枚举 在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化 enum des { top = 'TOP', right = 'RIGHT', bottom = 'BOTTOM', left = 'LEFT' } 由于字符串枚举没有自增长的行为，字符串枚举可以很好的序列化。 换句话说，如果你正在调试并且必须要读一个数字枚举的运行时的值，这个值通常是很难读的 - 它并不能表达有用的信息（尽管反向映射(后面会讲解)会有所帮助），字符串枚举允许你提供一个运行时有意义的并且可读的值，独立于枚举成员的名字 使用枚举 使用枚举很简单：通过枚举的属性来访问枚举成员，和枚举的名字来访问枚举类型： enum Des { top = 1, right, bottom, left } function fn1(des: Des):void { console.log(des) // 1 } fn1(Des.top) 计算的和常量成员 每个枚举成员都带有一个值，它可以是常量或计算出来的。 当满足如下条件时，枚举成员被当作是常量 它是枚举的第一个成员且没有初始化器，这种情况下它被赋予值0: // E.X is constant: enum E { X } 它不带有初始化器且它之前的枚举成员是一个 数字常量。 这种情况下，当前枚举成员的值为它上一个枚举成员的值加1 // All enum members in 'E1' and 'E2' are constant. enum E1 { X, Y, Z } enum E2 { A = 1, B, C } 枚举成员使用 常量枚举表达式初始化。 常数枚举表达式是TypeScript表达式的子集，它可以在编译阶段求值。 当一个表达式满足下面条件之一时，它就是一个常量枚举表达式 一个枚举表达式字面量（主要是字符串字面量或数字字面量） 一个对之前定义的常量枚举成员的引用（可以是在不同的枚举类型中定义的） 带括号的常量枚举表达式 一元运算符+,-,~其中之一应用在了常量枚举表达式 常量枚举表达式做为二元运算符+,-,*,/,%,&lt;&lt;,&gt;&gt;,&gt;&gt;&gt;,&amp;,|,^的操作对象。 若常数枚举表达式求值后为NaN或Infinity，则会在编译阶段报错 enum FileAccess { // constant members None, Read = 1 &lt;&lt; 1, Write = 1 &lt;&lt; 2, ReadWrite = Read | Write, // computed member G = &quot;123&quot;.length } 联合枚举与枚举成员的类型 存在一种特殊的非计算的常量枚举成员的子集：字面量枚举成员。 字面量枚举成员是指不带有初始值的常量枚举成员，或者是值被初始化为 任何字符串字面量（例如：&quot;foo&quot;，&quot;bar&quot;，&quot;baz&quot;） 任何数字字面量（例如：1,100） 应用了一元 -符号的数字字面量（例如：-1,-100） enum ShapeKind { Circle, Square, } interface Circle { kind: ShapeKind.Circle; radius: number; } interface Square { kind: ShapeKind.Square; sideLength: number; } let c: Circle = { kind: ShapeKind.Square, radius: 100, } enum E { Foo, Bar, } function f(x: E) { if (x !== E.Foo || x !== E.Bar) { // Error! Operator '!==' cannot be applied to types 'E.Foo' and 'E.Bar'. } } 运行时的枚举 enum E { X, Y, Z } function f(obj: { X: number }) { return obj.X; } // Works, since 'E' has a property named 'X' which is a number. f(E); 反向映射 除了创建一个以属性名做为对象成员的对象之外，数字枚举成员还具有了 反向映射，从枚举值到枚举名字 enum Enum { A } let a = Enum.A; let nameOfA = Enum[a]; // &quot;A&quot; 上面代码编译成Javascript var Enum; (function (Enum) { Enum[Enum[&quot;A&quot;] = 0] = &quot;A&quot;; })(Enum || (Enum = {})); var a = Enum.A; var nameOfA = Enum[a]; // &quot;A&quot; const枚举 const enum Enum { A = 1, B = A * 2 } 外部枚举 外部枚举用来描述已经存在的枚举类型的形状 declare enum Enum { A = 1, B, C = 2 } 外部枚举和非外部枚举之间有一个重要的区别，在正常的枚举里，没有初始化方法的成员被当成常数成员。 对于非常数的外部枚举而言，没有初始化方法时被当做需要经过计算的 上面我们介绍了TypeScript的枚举，第八节我们将介绍类型推论 文章参考TypeScript中文网 ","link":"https://xiaoai7904.github.io/post/typescript-ru-men-jiao-cheng-qi-mei/"},{"title":"TypeScript入门教程(六) - 泛型","content":" 维基百科 泛型是程序设计语言的一种风格或范式。泛型允许程序员在强类型程序设计语言中编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型 \b入门 下面通过\b两个例子来介绍泛型的基础用法 // 不适用泛型的情况 function fn1(arg: number): number { return arg } function fn2(arg: any): any { return arg } 上面例子是没有使用泛型的情况，我们使用泛型修改代码 function fn1&lt;T&gt;(arg: T): T { return arg } 我们通\b过添加类型变量T，T帮助我们\b捕获用户传入的类型，之后我们就可以使用这个类型，\b\b\b函数在返回T,这样我们可以知道参数类型和返回类型是相同并且可以\b跟踪函数使用的类型信息 上面一个简单的例子就是最简单的泛型\u001d的写法，&lt;&gt;里面的T\b可以随意修改，\b不一定是T 泛型变量 使用泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型，\b也就是说你必须把这些参数当做是任意或所有类型 function fn1&lt;T&gt;(arg:[]): T[] { console.log(Array.isArray(arg)) return arg } function fn2&lt;T&gt;(arg: Array&lt;T&gt;): Array&lt;T&gt; { return arg } 上面代码是一样的效果 泛型类型 泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样 function fn1&lt;T&gt;(arg: T):T { return arg } let f1: &lt;T&gt;(arg: T) =&gt; T = fn1 我们可能想把泛型参数当作整个接口的一个参数。 这样我们就能清楚的知道使用的具体是哪个泛型类型 interface fn1Face&lt;T&gt; { (arg: T): T; } function fn1&lt;T&gt;(arg: T): T { return arg } let f1: fn1Face&lt;number&gt; = fn1 泛型类 泛型类看上去与泛型接口差不多。 泛型类使用（ &lt;&gt;）括起泛型类型，跟在类名后面 class Styles&lt;T&gt; { width: T; height: T; setStyle: (width: T, height: T) =&gt; object } let fn1 = new Styles&lt;number&gt;() fn1.width = 100 fn1.height = 100 fn1.setStyle = function(width, height) {return {width,height}} 上面我们介绍了TypeScript的泛型，第七节我们将介绍枚举 文章参考TypeScript中文网 ","link":"https://xiaoai7904.github.io/post/typescript-ru-men-jiao-cheng-liu-fan-xing/"},{"title":"TypeScript入门教程(五) - 函","content":"函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块 函数 TypeScript中的函数和JavaScript中的函数一样，可以创建匿名函数和有名字的函数 // 命名函数 function fn1() {} // 匿名函数 let fn2 = function(){} 函数定义类型 我们可以给每个参数添加类型,而且可以给函数本身添加返回值类型。 TypeScript能够根据返回语句自动推断出返回值类型，因此我们一般会\b省略它，但是为了提升代码可以读性，一般我喜欢加上返回类型 function fn1(x: number, y: number): number { return x + y } let fn2: (x: number, y:number) =&gt; number = function(x: number, y:number):number{ return x + y} // 可以定义参数为可选参数 function fn3(x:number, y?:number): number { if(y) { return x + y } return x } this 通俗\b解释:this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象 function fn1() { console.log(this) } fn1() // window var fn = { fn1: function() { console.log(this) } } fn.fn1() // fn 重载 JavaScript是个动态语言，JavaScript里函数根据传入不同的参数而返回不同类型的数据是很常见的 function fn1(data: object | string | any): any{ if(typeof data === 'object') { return {} }else if(typeof data === 'string') { return '' } return false } 上面代码函数fn1接受一个参数,这个参数类型可以是对象，字符串或者其他类型，函数体内会根据接受的参数返回不同值 方法是为同一个函数提供多个函数类型定义来进行函数重载。 编译器会根据这个列表去处理函数的调用 function fn1(data: object): object; function fn1(data: number): boolean function fn1(data: any): any { if(typeof data === 'object') { return {} }else if(typeof data === 'string') { return '' } return false } fn1({}) fn1(1) fn1('') 这样改变后，重载的fn1函数在调用的时候会进行正确的类型检查 为了让编译器能够选择正确的检查类型，它与JavaScript里的处理流程相似。 它查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。 因此，在定义重载的时候，一定要把最精确的定义放在最前面 上面我们介绍了TypeScript的函数，第六节我们将介绍泛型 文章参考TypeScript中文网 彻底\b理解this JavaScript中的this-阮一峰 ","link":"https://xiaoai7904.github.io/post/typescript-ru-men-jiao-cheng-wu-han/"},{"title":"TypeScript入门教程(四) - 类","content":"在传统JavaScript中类是基于原型模拟出来的类，在\bES6中新增class关键字来书写基于类的面向对象(底层还是基于原型的方式\b) 类 维基百科 -&gt; 在面向对象编程，类（英语：class）是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法 ES5中的\b模拟类: function Fn1(name, age) { this.name = name this.age = age } Fn1.prototype = { constructor: Fn1, setAge: function(age) { this.age = age console.log(age) } } ES6中的类 class Fn1 { constructor(name, age) { this.name = name this.age = age } setAge(age) { this.age = age console.log(age) } } TypeScript中的类 class Fn1 { constructor(name: string, age: number) { this.name = name this.age = age } setAge(age: number): void{ this.age = age console.log(age) } } 继承 在TypeScript里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类 class Fn1 { constructor(name: string, age: number) { this.name = name this.age = age } setAge(age: number): void { this.age = age console.log(this.age) } } class Fn2 extends Fn1{ constructor(name: string, age: number) { this.name = name this.age = age } } let fn1 = new Fn2('mickey', 26) fn1.setAge(27) // 27 继承我们可以通过关键字extends来继承 ES5中的继承方式推荐大家看一下\b阮一峰的博客构造函数的继承 public修饰符 C#要求必须明确地使用 public指定成员是可见的。 在TypeScript里，成员都默认为 public class Fn1 { public name: string public constructor(name: string, age: number) { this.name = name this.age = age } public setAge(age: number): void { this.age = age } } private修饰符 当成员被标记成 private时，它就不能在声明它的类的外部访问 class Fn1 { private name: string public constructor(name: string, age: number) { this.name = name } } new Fn1().name // error 'name'是私有的 protected protected修饰符与 private修饰符的行为很相似，但有一点不同， protected成员在派生类中仍然可以访问 class Fn1 { protected name: string constructor(name: string, age: number) { this.name = name } } class Fn2 extends Fn1{ constructor(name: string) { super(name) } public getName() { console.log(this.name) } } new Fn2('mickey').name // error new Fn2('mickey').getName() // mickey 我们不能在Fn1类外使用name，但是我们可以在派生出来的\b实例方法上使用name readonly修饰符 你可以使用 readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化 class Fn1 { readonly name: string constructor(name: string) { this.name = name } } let f = new Fn2('mickey') f.name = 'xxx' // error name是只读 参数属性 class Fn1 { constructor(private name: string) { } getName(): string { console.log(this.name) return this.name } } 上面代码我们通过在constructor参数private name: string来进行创建和初始化,我们就声明和赋值合并在一起了，public和 protected的使用也是一样 存取器 TypeScript支持通过getters/setters来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问 let passcode = &quot;secret passcode&quot;; class Employee { private _fullName: string; get fullName(): string { return this._fullName; } set fullName(newName: string) { if (passcode &amp;&amp; passcode == &quot;secret passcode&quot;) { this._fullName = newName; } else { console.log(&quot;Error: Unauthorized update of employee!&quot;); } } } let employee = new Employee(); employee.fullName = &quot;Bob Smith&quot;; if (employee.fullName) { alert(employee.fullName); } 存取器要求你将编译器设置为输出ECMAScript 5或更高。 不支持降级到ECMAScript 3。 其次，只带有get不带有set的存取器自动被推断为 readonly。 这在从代码生成 .d.ts文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值 static修饰符 我们可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上 class Styles { static width = 200 constructor(public style: object) {} getWidth() { console.log(Styles.width) // 200 } } new Styles({height: 200}) 抽象类 抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。 abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法 abstract class Department { constructor(public name: string) { } printName(): void { console.log('Department name: ' + this.name); } abstract printMeeting(): void; // 必须在派生类中实现 } class AccountingDepartment extends Department { constructor() { super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super() } printMeeting(): void { console.log('The Accounting Department meets each Monday at 10am.'); } generateReports(): void { console.log('Generating accounting reports...'); } } let department: Department; // 允许创建一个对抽象类型的引用 department = new Department(); // 错误: 不能创建一个抽象类的实例 department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值 department.printName(); department.printMeeting(); department.generateReports(); // 错误: 方法在声明的抽象类中不存在 上面我们介绍了TypeScript的类，第五节我们将介绍函数 文章参考TypeScript中文网 阮一峰Es6 ","link":"https://xiaoai7904.github.io/post/typescript-ru-men-jiao-cheng-si-lei/"},{"title":"TypeScript入门教程(三) - 接口","content":"TypeScript的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约 初次见面接口 先看一段实例代码 function fn1(styles: {wdith: number}): void { console.log(styles.wdith) } fn1({width: 100, height: 200}) 上面的代码函数接受一个参数名styles里面有属性width类型是number,但是我们传了其他属性，\b编译器只会检查那些必需的属性是否存在，然而，有些时候TypeScript却并不会这么宽松 我们修改一下上面的例子，通过接口在实现 interface Styles { width: number } function fn1(styles: Styles): void { console.log(styles.wdith) } fn1({width: 100, height: 200}) // 这里会报错说height没有定义在接口中 Styles接口就是名字，用来描述上面例子里面的需求，它表示有一个width属性类型为\bnumber， 需要注意的是，我们在这里并不能像在其它语言里一样，说传给fn1的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的 类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以 可选属性 接口里面的属性不全部是必须的，我们可以不传一些参数 interface Styles { width: number, height?: number } function fn1(styles: Styles): void { console.log(style) } fn1({width: 100}) // ok 带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号 只读属性 一些对象属性只是\b只读，你不能修改它的值 interface Styles { readonly width: number, readonly height: number } let styles: Styles = {width: 100, height: 200} styles.width = 200 // error widht是只读属性不能修改 数组也可以创建只读，TypeScript具有ReadonlyArray类型，可以确保数组创建后再也不能被修改： let list1: number[] = [1, 2, 3, 4]; let ro: ReadonlyArray&lt;number&gt; = a; ro[0] = 12; // error! ro.push(5); // error! ro.length = 100; // error! list1 = ro; // error! 上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写 list1 = ro as number[]; 函数类型 \b接口可以描述对象也可以描述函数类型 interface fn1 { (width: number, height: number): object&lt;{width: number, height: number}&gt; } 上面我们定义了一个函数类型的接口，下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量 let stylesFn: fn1 stylesFn = function(width: number, height: number){ return { width,height } } 可索引的类型 与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如styles[0]或styles[&quot;width&quot;],可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型 interface Styles { [index: number]: number } let styles: Styles styles = [100, 200] let width: number = styles[0] 类类型 与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约 interface Styles { width: number, setStyle(s: object) } class CreateStyles implements Styles { width: number constructor() {} setStyle(s: object): void {} } 继承接口 和类一样，接口也可以相互继承，我们可以从一个接口复制成员到另一个接口 interface Styles { width: number height: number } interface Styles1 extends Styles { color: string } let s = &lt;Styles1&gt;{} s.color = 'red' s.width = 100 s.height = 200 接口可以继承多个接口 interface Styles { width: number height: number } interface Styles1 { border: string } interface Styles2 extends Styles, Styles1{ color: string } let s = &lt;Styles2&gt;{} s.color = 'red' s.width = 100 s.height = 200 s.border = '1px solid red' 混合类型 接口可以同时用于对象和函数使用 interface Styles { width: number reset(): void (style: object): void } function createStyles(): Styles { let initStyle = &lt;Styles&gt;function(style: object){} initStyle.width = 200 initStyle.reset = function() {} } 在使用JavaScript第三方库的时候，你可能需要像上面那样去完整地定义类型 上面我们介绍了TypeScript的接口，第四节我们将介绍类 文章参考TypeScript中文网 ","link":"https://xiaoai7904.github.io/post/typescript-ru-men-jiao-cheng-san-jie-kou/"},{"title":"TypeScript入门教程(二) - 变量声明","content":"在es5中js声明变量是通过var关键字进行变量声明，在es6中我们可以通过let,const两个关键字来进行声明，typescript中支持let,const进行声明变量 Var 在过去的js中(es5之前包括es5)我们声明变量是通过var来声明一个变量，但是var声明变量也有它不足的地方，我们接下来会详细介绍它 var a = 'mickey' 通过上面的方式我们就声明了一个变量a类型是字符串值为'mickey' 我们也可以在函数中声明变量 function fn1() { var age = 26 } 如果你是像Java,C等其他语言开发人员会对js中的var声明的变量作用域看起来很奇怪 function fn1(flag: boolean): void | number { if(flag) { var num = 26 } return num } fn1(false) // return undefined fn1(true) // 26 \b上面的例子中，变量num声明在if语句中，但是我们在\b语句的外面还是可以访问它，这是因为var声明可以包含在函数，模块，命名空间和全局作用域内部任何位置被访问，js通过var声明的\b变量是没有块级作用域 我们在看一个例子 var a = document.getElementsByTagName(&quot;a&quot;); for(var i = 0; i &lt; 7; i++){ a[i].onclick = function(){ console.log(i) } } // 这里我们点击a标签会输入 7 // 因为循环创建了i变量\b后面会直接覆盖前面的变量值 \b\b为了解决上面的问题我们可以通过闭包来解决 var a = document.getElementsByTagName(&quot;a&quot;); for(var i =0; i&lt;a.length; i++){ a[i].onclick = (function(i){ return function(){alert(i);} })(i); } 还有一种方式通过es6中的let来解决,接下来我们详细介绍let Let 使用let和之前var声明变量一样 let a = 'mickey' let b: number = 26 我们通过let声明\b的方式解决上面的问题 var a = document.getElementsByTagName(&quot;a&quot;); for(let i = 0; i &lt; 7; i++){ a[i].onclick = function(){ console.log(i) } } // 这里我们点击a标签会输入 0,1,2,3,4,5,6,7 如果你想了解比较详细let如果使用和\b新的特性你可以参考ECMAScript 6 入门-阮一峰 Const 使用Const和之前var声明变量一样 const a = 'mickey' const b: number = 26 如果你想了解比较详细Const如果使用和\b新的特性你可以参考ECMAScript 6 入门-阮一峰 解构 数组解构 let input = [1, 2]; let [first, second] = input; console.log(first); // outputs 1 console.log(second); // outputs 2 function f([first, second]: [number, number]) { console.log(first); console.log(second); } f(input); let [first, ...rest] = [1, 2, 3, 4]; console.log(first); // outputs 1 console.log(rest); // outputs [ 2, 3, 4 ] 对象解构 let o = { a: &quot;foo&quot;, b: 12, c: &quot;bar&quot; }; let { a, b } = o; ({ a, b } = { a: &quot;baz&quot;, b: 101 }); 上面简单的介绍了数组解构和对象解构，如果你想详情了解还是推荐你去ECMAScript 6 入门-阮一峰这个对ES6进行非常详细的介绍，相信你会学到很多ES6中所有新特性 上面我们介绍了TypeScript的变量声明，第三节我们将介绍接口 文章参考TypeScript中文网 ","link":"https://xiaoai7904.github.io/post/typescript-ru-men-jiao-cheng-er-bian-liang-sheng-ming/"},{"title":"TypeScript入门教程(一) - 基础类型","content":" Typescript中的基础类型和JavaScript中定义的五种基本类型(Number,String,Boolean,Undefined,Null)几乎相同,还新增了枚举类型,接下来我们详细介绍TypeScript中的基础类型 布尔值(Boolean) 布尔值类型就是简单的true or false let isShow: boolean = true // :后面是指定变量isShow的类型，如果修改了isShow的变量类型为非boolean值就会报错 数字(Number) Typescript中的数字类型和Javascript中的数字类型一样都是浮点数 let age: number = 26 let money: number = 6000.04 let hex: number = 0xf00d let binary: number = 0b1010 let octal: number = 0o744 字符串(String) Typescript中的字符串和JavaScript字符串写法一样都是通过双引号(&quot;&quot;)或者单引号('')表示字符串 let str1: string = 'hi' let str2: string = &quot;hi&quot; Null和Undefined Typescript中null和undefined两个各自有自己的类型分别是null和undefined let u: undefined = undefined let n: null = null // undefined和null是所有类型的子集，就是你可以把所有类型赋值成undefined和null 数组(Array) Typescript里面的数组和JavaScript中一样都可以操作数组元素,在Typescript中有两种定义数组的方式 // 方法一: let list1: string[] = ['name1', 'name2', 'name3'] let list2: number[] = [1,2,3] // 方法二: let list3: Array&lt;string&gt; = ['name1', 'name2', 'name3'] let list4: Array&lt;number&gt; = [1,2,3] 元组(Tuple) 元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组 let t: [string, number] t = ['mickey', 26] // ok t = [26, 'mickey'] // error 枚举(Enum) enum类型是在JavaScript类型中新增的类型, 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字 enum Style {width, height, color} let warp: Style = Style.width 默认情况下，枚举里面的值是从0开始为元素编号，也可以手动的指定成员的数值 enum Style {width = 1, height = 2, color = 4} let wrap: Style = Style.width // 也可以通过枚举的值得到它的名字 let wrap: Style = Style[2] // height Any 我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查就可以使用any类型来标记这些变量 let a: any = 'mickey' a = 26 a = function(){} let list1: Array&lt;any&gt; = [1,'name1', true] 通过any定义的变量在后面可以随意赋值成其他类型的变量,这个就和js使用一样，js是弱类型语言定义变量可以不指定类型而且可以随意修改变量类型 Void 某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void function fn(): void { console.log('test...') } // 声明变量为void 你只能为它赋值为 undefined和null let a: void = undefined let b: void = null Never never类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类型保护所约束时 never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never // 返回never的函数必须存在无法达到的终点 function fn1(): never { throw new Error('error') } // 推断的返回值类型为never function fn2(): never { return error('error') } // 返回never的函数必须存在无法达到的终点 function fn3(): never { while(true) {} } 上面我们介绍了TypeScript的基础类型，第二节我们将介绍变量声明 文章参考TypeScript中文网 ","link":"https://xiaoai7904.github.io/post/typescript-ru-men-jiao-cheng-yi-ji-chu-lei-xing/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://xiaoai7904.github.io/post/hello-gridea/"},{"title":"JavaScript函数","content":"概念 函数是由事件驱动的或者当它被调用执行的可复用的代码块 js支持两种函数： 语言内部的函数（如eval()） 自己创建的函数 在js函数内部声明的变量(使用var)是局部变量，只能在函数内部访问它 你可以在不同的函数声明相同的变量名称，因为它们是局部变量，两个不会相互影响 函数调用 四种调用方式： 作为函数 作为方法 作为构造函数 通过call()和apply() 返回函数的函数 当函数无明确返回值时，返回undefined 当函数结束有return,返回什么就是什么 我们可以利用return语句实现将函数返回值，或者单纯的结束函数 在使用了return的时候，函数会立即停止执行，如果return了值出去，函数的值就为返回的值 函数通常会返回一个唯一值，这个值可能是另一个函数 function fn(){ var a = 10; var b = 20; var c = a +ｂ； return c; } console.log(fn());//输出30； //我们可以返回的函数赋值给你个变量 var fn1 = fn(); console.log(fn1);//输出30； //如果我们想返回的函数立即执行我们可以这样 var fn2 = fn()();//在加一个括号表示立即执行函数 js函数传递参数都是按照值传递。 引用类型： js中引用类型都是存储在堆内存中的对象，变量中保存的实际只是一个指针，这个指针执行内存中的另一个位置，这个位置保存对象。 创建匿名函数 function(){ console.log('我是一个没有名字的函数') }() 这种函数的好处是在我们只使用一次，省的在去定义一个函数名，避免命名冲突，js中没有命名空间的概念，因此有两个相同的函数名字，js会执行后面那个函数，因为js解析代码是一段一段的执行，他会按照最后出现的执行 通过自我执行来执行匿名函数： (function(){ console.log('打开程序我马上就执行啦！！！') })() 把匿名函数自我执行的返回值赋值给变量： var fn = (function(){ return 'hi'; })(); console.log(fn);//输出hi 自我执行匿名函数的传参： (function(a){ console.log(a);//输出10 })(10) js创建动态函数 js支持创建动态函数，动态函数必须用Function对象来定义(Function是js中的一个对象，他是引用类型，是固定不变的，对象中的Function中的'F'必须大小） 创建动态函数的基本格式：var 变量名 = new Function('参数1','参数2'，'参数n','执行语句') var fn = new Function('x','y','var sum ; sum = x + y ; return sum;') console.log(fn(2,3));//输出5 //上面的代码等同于： var fn = function(x,y){ var sum; sum = x + y; return sum; } console.log(fn(2,3));//输出5 //第一个函数是动态函数，第二个函数是静态函数 一般情况下我们不使用动态函数 回调函数 回调函数是一个函数的调用的过程，简单理解就是一个函数里面传参数，传的参数是一个函数，第一个函数执行完成后再去执行第二个函数。 function fn(fn1){ console.log('aa')； fn1(); } function fn1(){ console.log('bb'); } fn(fn1); //先执行fn函数，fn函数执行完成后再执行fn1函数 //这里fn1函数就是回调函数 方法和函数的区别 var arr = [1,2,3,4,5] var a =12; // 变量：自由的 arr.a= 5; //属性：属于一个对象 function show() //函数：自由的 { alert(‘a’); } arr.fn = function() //方法：属于一个对象 { alert(‘b’); } 其实方法就是函数，只不过方法是所属的对象 JS全局函数 js中有7中全局函数： escape( )、eval( )、isFinite( )、isNaN( )、parseFloat( )、parseInt( )、unescape( ) 函数的几个作用 作为一个类构造器使用 function Class(){}; Class.prototype = {}; var item = new Class(); 作为闭包使用 (function(){ //独立的作用域 })（） 作为构造函数调用 function Person(name,age){ this.name = name; this.age = age; } var per1 = new Person('xiaoming',19); var per2 = new Person('xiaohong',20); per1.name;//输出'xiaoming' per1.age;//输出19 per2.name;//输出'xiaohong' per2.age;//输出20 可以使用 new 运算符结合像 Object()、Date() 和 Function() 这样的预定义的构造函数来创建对象并对其初始化。面向对象的编程其强有力的特征是定义自定义构造函数以创建脚本中使用的自定义对象的能力。创建了自定义的构造函数，这样就可以创建具有已定义属性的对象。 优缺点： 使用构造器函数的优点是，它可以根据参数来构造不同的对象。 缺点是构造时每个实例对象都会生成重复调用对象的方法，造成了内存的浪费 作为值的函数 JS中函数是一种语法，也是一个值，我们可以把函数赋值给一个变量 function fn(x,y){ return x * y } var newFn = fn(); fn(2,3);//输出6 newFn(3,4);//输出12 函数也可以赋值给一个对象的属性，我们称为方法 function fn(x,y){ return x * y } var obj = {};//我们这里定义了一个空对象obj obj.seque = fn(2.3);//我们给空对象obj动态赋值了一个属性为seque 高阶函数 这里的高阶函数可不是高数里的那个高阶函数，所谓高阶函数就是操作函数的函数，它接收一个或多个函数作为参数，并返回新函数 call()和apply() call()函数里面第一个参数是执行上下文，第二个是传递的参数。。。可以传递多个参数 function.call(this,1,2,3); apply()函数里面第一个参数是执行上下文，第二个是一个数组对象。 function.apply(this,[1,2,3]); 这部分后面还要完善，这里只是简单的介绍一下 add 2016.8.12 函数里面的参数(arguments) 当函数被调用的时候，会得到一个参数数组，那就是arguments数组，通过它，函数可以访问所有它被调用时传递给它的参数 var sum = function(){ var i ,sum =0; for(i = 0;i&lt;arguments.length;i+=1){ sum+=arguments[i]; } return sum; }; console.log(sum(4,5,23,13,35,46,-10));//116 实际上，arguments并不是一个真正的数组，它只是一个类数组的对象，它拥有一个length属性，但他缺少所有数组的方法。另外，arguments对象的长度是由传入的参数个数决定的，而不是由定义函数时的命名参数的个数决定的 函数在定义或者声明的时候，所有的参数都是形参，因此，我们可以根据实际情况来命名参数，函数也只有在被调用时才会传入实参。而每个函数在被调用时都会自动取得两个特殊变量：this 和 arguments 递归函数 函数的递归，即一个函数在通过名字调用自身的情况下构成的 私有变量和私有函数 定义在函数内部的变量和函数，如果不对外提供接口，外面是访问不到这些函数和变量的，这就叫做私有变量和私有函数 function Fn(){ var a = 10;//私有变量 var fn1 = function(){};//私有函数 } var newFn = new Fn(); console.log(newFn.a);//undefined console.log(newFn.fn1);//undefined 静态变量和函数 当定义一个函数后通过点号 “.”为其添加的属性和函数，通过对象本身仍然可以访问得到，但是其实例却访问不到，这样的变量和函数分别被称为静态变量和静态函数。 function Obj(){}; Obj.num = 72;//静态变量 Obj.fn = function(){}//静态函数 alert(Obj.num);//72 alert(typeof Obj.fn)//function var t = new Obj(); alert(t.name);//undefined alert(typeof t.fn);//undefined 实例变量和函数 在面向对象编程中除了一些库函数我们还是希望在对象定义的时候同时定义一些属性和方法，实例化后可以访问，js也能做到这样 function Box(){ this.a=[]; //实例变量 this.fn=function(){ //实例方法 } } console.log(typeof Box.a); //undefined console.log(typeof Box.fn); //undefined var box=new Box(); console.log(typeof box.a); //object console.log(typeof box.fn); //function 为实例变量和方法添加新的方法和属性 function Box(){ this.a=[]; //实例变量 this.fn=function(){ //实例方法 } } var box1=new Box(); box1.a.push(1); box1.fn={}; console.log(box1.a); //[1] console.log(typeof box1.fn); //object var box2=new Box(); console.log(box2.a); //[] console.log(typeof box2.fn); //function 在box1中修改了a和fn，而在box2中没有改变，由于数组和函数都是对象，是引用类型，这就说明box1中的属性和方法与box2中的属性与方法虽然同名但却不是一个引用，而是对Box对象定义的属性和方法的一个复制。 这个对属性来说没有什么问题，但是对于方法来说问题就很大了，因为方法都是在做完全一样的功能，但是却又两份复制，如果一个函数对象有上千和实例方法，那么它的每个实例都要保持一份上千个方法的复制，这显然是不科学的，这可肿么办呢，prototype应运而生。 prototype属性 基本概念： 我们创建的每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。那么，prototype就是通过调用构造函数而创建的那个对象实例的原型对象。 使用原型的好处是可以让对象实例共享它所包含的属性和方法。也就是说，不必在构造函数中添加定义对象信息，而是可以直接将这些信息添加到原型中。使用构造函数的主要问题就是每个方法都要在每个实例中创建一遍。 在JavaScript中,一共有两种类型的值,原始值和对象值。每个对象都有一个内部属性 prototype ,我们通常称之为原型。原型的值可以是一个对象,也可以是null。如果它的值是一个对象，则这个对象也一定有自己的原型。这样就形成了一条线性的链，我们称之为原型链 ","link":"https://xiaoai7904.github.io/post/javascript-han-shu/"}]}