<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TypeScript入门教程(七) - 枚 | xiaoai</title>
<meta name="description" content="记录美好生活" />
<link rel="shortcut icon" href="https://xiaoai7904.github.io//favicon.ico?v=1575862739093">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://xiaoai7904.github.io//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://xiaoai7904.github.io/">
  <img class="avatar" src="https://xiaoai7904.github.io//images/avatar.png?v=1575862739093" alt="">
  </a>
  <h1 class="site-title">
    xiaoai
  </h1>
  <p class="site-description">
    记录美好生活
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              TypeScript入门教程(七) - 枚
            </h2>
            <div class="post-info">
              <span>
                2019-11-24
              </span>
              <span>
                5 min read
              </span>
              
                <a href="https://xiaoai7904.github.io//tag/4kuYU9V7d" class="post-tag">
                  # JavaScript
                </a>
              
            </div>
            
              <img class="post-feature-image" src="https://www.sitepen.com/blog/wp-content/uploads/2017/11/blog-image.png" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript支持数字的和基于字符串的枚举</p>
<!--more-->
<h3 id="数字枚举">数字枚举</h3>
<pre><code class="language-typescript">enum des {
    top = 1,
    right,
    bottom,
    left
}
</code></pre>
<p>上面代码定义了数字枚举,top使用初始化值为<code>1</code>,其余的成员就会从<code>1</code>开始自动增长</p>
<p>我们也可以不制定初始化值，那么<code>top</code>就会是<code>0</code>，其他成员就会从<code>0</code>开始增长</p>
<h3 id="字符串枚举">字符串枚举</h3>
<p>在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化</p>
<pre><code class="language-typescript">enum des {
   top = 'TOP',
   right = 'RIGHT',
   bottom = 'BOTTOM',
   left = 'LEFT'
}
</code></pre>
<p>由于字符串枚举没有自增长的行为，字符串枚举可以很好的序列化。 换句话说，如果你正在调试并且必须要读一个数字枚举的运行时的值，这个值通常是很难读的 - 它并不能表达有用的信息（尽管<code>反向映射</code>(后面会讲解)会有所帮助），字符串枚举允许你提供一个运行时有意义的并且可读的值，独立于枚举成员的名字</p>
<h3 id="使用枚举">使用枚举</h3>
<p>使用枚举很简单：通过枚举的属性来访问枚举成员，和枚举的名字来访问枚举类型：</p>
<pre><code class="language-typescript">enum Des {
    top = 1,
    right,
    bottom,
    left
}

function fn1(des: Des):void {
    console.log(des) // 1
}

fn1(Des.top)
</code></pre>
<h3 id="计算的和常量成员">计算的和常量成员</h3>
<p>每个枚举成员都带有一个值，它可以是<code>常量</code>或<code>计算出来的</code>。 当满足如下条件时，枚举成员被当作是常量</p>
<ul>
<li>它是枚举的第一个成员且没有初始化器，这种情况下它被赋予值<code>0</code>:</li>
</ul>
<pre><code class="language-typescript">// E.X is constant:
enum E { X }
</code></pre>
<ul>
<li>它不带有初始化器且它之前的枚举成员是一个 数字常量。 这种情况下，当前枚举成员的值为它上一个枚举成员的值加<code>1</code></li>
</ul>
<pre><code class="language-typescript">// All enum members in 'E1' and 'E2' are constant.

enum E1 { X, Y, Z }

enum E2 {
    A = 1, B, C
}
</code></pre>
<ul>
<li>枚举成员使用 常量枚举表达式初始化。 常数枚举表达式是TypeScript表达式的子集，它可以在编译阶段求值。 当一个表达式满足下面条件之一时，它就是一个常量枚举表达式
<ul>
<li>一个枚举表达式字面量（主要是字符串字面量或数字字面量）</li>
<li>一个对之前定义的常量枚举成员的引用（可以是在不同的枚举类型中定义的）</li>
<li>带括号的常量枚举表达式</li>
<li>一元运算符<code>+</code>,<code>-</code>,<code>~</code>其中之一应用在了常量枚举表达式</li>
<li>常量枚举表达式做为二元运算符<code>+</code>,<code>-</code>,<code>*</code>,<code>/</code>,<code>%</code>,<code>&lt;&lt;</code>,<code>&gt;&gt;</code>,<code>&gt;&gt;&gt;</code>,<code>&amp;</code>,<code>|</code>,<code>^</code>的操作对象。 若常数枚举表达式求值后为<code>NaN</code>或<code>Infinity</code>，则会在编译阶段报错</li>
</ul>
</li>
</ul>
<pre><code class="language-typescript">enum FileAccess {
    // constant members
    None,
    Read    = 1 &lt;&lt; 1,
    Write   = 1 &lt;&lt; 2,
    ReadWrite  = Read | Write,
    // computed member
    G = &quot;123&quot;.length
}
</code></pre>
<h3 id="联合枚举与枚举成员的类型">联合枚举与枚举成员的类型</h3>
<p>存在一种特殊的非计算的常量枚举成员的子集：字面量枚举成员。 字面量枚举成员是指不带有初始值的常量枚举成员，或者是值被初始化为</p>
<ul>
<li>任何字符串字面量（例如：<code>&quot;foo&quot;</code>，<code>&quot;bar&quot;</code>，<code>&quot;baz&quot;</code>）</li>
<li>任何数字字面量（例如：<code>1</code>,<code>100</code>）</li>
<li>应用了一元 <code>-</code>符号的数字字面量（例如：<code>-1</code>,<code>-100</code>）</li>
</ul>
<pre><code class="language-typescript">enum ShapeKind {
    Circle,
    Square,
}

interface Circle {
    kind: ShapeKind.Circle;
    radius: number;
}

interface Square {
    kind: ShapeKind.Square;
    sideLength: number;
}

let c: Circle = {
    kind: ShapeKind.Square,
    radius: 100,
}
</code></pre>
<pre><code class="language-typescript">enum E {
    Foo,
    Bar,
}

function f(x: E) {
    if (x !== E.Foo || x !== E.Bar) {
        // Error! Operator '!==' cannot be applied to types 'E.Foo' and 'E.Bar'.
    }
}
</code></pre>
<h3 id="运行时的枚举">运行时的枚举</h3>
<pre><code class="language-typescript">enum E {
    X, Y, Z
}

function f(obj: { X: number }) {
    return obj.X;
}

// Works, since 'E' has a property named 'X' which is a number.
f(E);
</code></pre>
<h3 id="反向映射">反向映射</h3>
<p>除了创建一个以属性名做为对象成员的对象之外，数字枚举成员还具有了 反向映射，从枚举值到枚举名字</p>
<pre><code class="language-typescript">enum Enum {
    A
}
let a = Enum.A;
let nameOfA = Enum[a]; // &quot;A&quot;
</code></pre>
<p>上面代码编译成<code>Javascript</code></p>
<pre><code class="language-javascript">var Enum;
(function (Enum) {
    Enum[Enum[&quot;A&quot;] = 0] = &quot;A&quot;;
})(Enum || (Enum = {}));
var a = Enum.A;
var nameOfA = Enum[a]; // &quot;A&quot;
</code></pre>
<h3 id="const枚举">const枚举</h3>
<pre><code class="language-typescript">const enum Enum {
    A = 1,
    B = A * 2
}
</code></pre>
<h3 id="外部枚举">外部枚举</h3>
<p>外部枚举用来描述已经存在的枚举类型的形状</p>
<pre><code class="language-typescript">declare enum Enum {
    A = 1,
    B,
    C = 2
}
</code></pre>
<p>外部枚举和非外部枚举之间有一个重要的区别，在正常的枚举里，没有初始化方法的成员被当成常数成员。 对于非常数的外部枚举而言，没有初始化方法时被当做需要经过计算的</p>
<p>上面我们介绍了<code>TypeScript</code>的枚举，第八节我们将介绍类型推论</p>
<blockquote>
<p>文章参考<a href="https://www.tslang.cn/docs/handbook/variable-declarations.html">TypeScript中文网</a></p>
</blockquote>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#%E6%95%B0%E5%AD%97%E6%9E%9A%E4%B8%BE">数字枚举</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9E%9A%E4%B8%BE">字符串枚举</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE">使用枚举</a></li>
<li><a href="#%E8%AE%A1%E7%AE%97%E7%9A%84%E5%92%8C%E5%B8%B8%E9%87%8F%E6%88%90%E5%91%98">计算的和常量成员</a></li>
<li><a href="#%E8%81%94%E5%90%88%E6%9E%9A%E4%B8%BE%E4%B8%8E%E6%9E%9A%E4%B8%BE%E6%88%90%E5%91%98%E7%9A%84%E7%B1%BB%E5%9E%8B">联合枚举与枚举成员的类型</a></li>
<li><a href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E6%9E%9A%E4%B8%BE">运行时的枚举</a></li>
<li><a href="#%E5%8F%8D%E5%90%91%E6%98%A0%E5%B0%84">反向映射</a></li>
<li><a href="#const%E6%9E%9A%E4%B8%BE">const枚举</a></li>
<li><a href="#%E5%A4%96%E9%83%A8%E6%9E%9A%E4%B8%BE">外部枚举</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://xiaoai7904.github.io//post/typescript-ru-men-jiao-cheng-liu-fan-xing">
              <h3 class="post-title">
                TypeScript入门教程(六) - 泛型
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '542a046d9cd2c40810d6',
    clientSecret: '3f40254747f30cec544eed0010a8671076c68908',
    repo: 'xiaoai7904.github.io',
    owner: 'xiaoai7904',
    admin: ['xiaoai7904'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://xiaoai7904.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()

  let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

  // This should probably be throttled.
  // Especially because it triggers during smooth scrolling.
  // https://lodash.com/docs/4.17.10#throttle
  // You could do like...
  // window.addEventListener("scroll", () => {
  //    _.throttle(doThatStuff, 100);
  // });
  // Only not doing it here to keep this Pen dependency-free.

  window.addEventListener("scroll", event => {
    let fromTop = window.scrollY;

    mainNavLinks.forEach((link, index) => {
      let section = document.getElementById(decodeURI(link.hash).substring(1));
      let nextSection = null
      if (mainNavLinks[index + 1]) {
        nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
      }
      if (section.offsetTop <= fromTop) {
        if (nextSection) {
          if (nextSection.offsetTop > fromTop) {
            link.classList.add("current");
          } else {
            link.classList.remove("current");    
          }
        } else {
          link.classList.add("current");
        }
      } else {
        link.classList.remove("current");
      }
    });
  });

</script>

      </div>
    </div>
  </body>
</html>
