<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TypeScript入门教程(四) - 类 | xiaoai</title>
<meta name="description" content="记录美好生活" />
<link rel="shortcut icon" href="https://xiaoai7904.github.io//favicon.ico?v=1574595674899">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://xiaoai7904.github.io//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://xiaoai7904.github.io/">
  <img class="avatar" src="https://xiaoai7904.github.io//images/avatar.png?v=1574595674899" alt="">
  </a>
  <h1 class="site-title">
    xiaoai
  </h1>
  <p class="site-description">
    记录美好生活
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              TypeScript入门教程(四) - 类
            </h2>
            <div class="post-info">
              <span>
                2019-11-24
              </span>
              <span>
                6 min read
              </span>
              
                <a href="https://xiaoai7904.github.io//tag/4kuYU9V7d" class="post-tag">
                  # JavaScript
                </a>
              
            </div>
            
              <img class="post-feature-image" src="https://www.sitepen.com/blog/wp-content/uploads/2017/11/blog-image.png" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>在传统<code>JavaScript</code>中类是基于原型模拟出来的类，在ES6中新增<code>class</code>关键字来书写基于类的面向对象(底层还是基于原型的方式)</p>
<!--more-->
<h3 id="类">类</h3>
<blockquote>
<p>维基百科 -&gt; 在面向对象编程，类（英语：class）是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法</p>
</blockquote>
<ul>
<li>ES5中的模拟类:</li>
</ul>
<pre><code class="language-typescript">function Fn1(name, age) {
    this.name = name
    this.age = age
}
Fn1.prototype = {
    constructor: Fn1,
    setAge: function(age) {
        this.age = age
        console.log(age)
    }
}
</code></pre>
<ul>
<li>ES6中的类</li>
</ul>
<pre><code class="language-typescript">class Fn1 {
    constructor(name, age) {
        this.name = name
        this.age = age
    }
    setAge(age) {
        this.age = age
        console.log(age)
    }   
}
</code></pre>
<ul>
<li>TypeScript中的类</li>
</ul>
<pre><code class="language-typescript">class Fn1 {
    constructor(name: string, age: number) {
        this.name = name
        this.age = age
    }
    setAge(age: number): void{
        this.age = age
        console.log(age)
    }   
}
</code></pre>
<h3 id="继承">继承</h3>
<p>在TypeScript里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类</p>
<pre><code class="language-typescript">class Fn1 {
    constructor(name: string, age: number) {
        this.name = name
        this.age = age
    }
    setAge(age: number): void {
        this.age = age
        console.log(this.age)
    }
}
class Fn2 extends Fn1{
    constructor(name: string, age: number) {
        this.name = name
        this.age = age
    }
}

let fn1 = new Fn2('mickey', 26)
fn1.setAge(27) // 27
</code></pre>
<p>继承我们可以通过关键字<code>extends</code>来继承</p>
<p>ES5中的继承方式推荐大家看一下阮一峰的博客<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html">构造函数的继承</a></p>
<h3 id="public修饰符">public修饰符</h3>
<p>C#要求必须明确地使用 public指定成员是可见的。 在TypeScript里，成员都默认为 public</p>
<pre><code class="language-typescript">class Fn1 {
    public name: string
    public constructor(name: string, age: number) {
        this.name = name
        this.age = age
    }
    public setAge(age: number): void {
        this.age = age
    }
}
</code></pre>
<h3 id="private修饰符">private修饰符</h3>
<p>当成员被标记成 private时，它就不能在声明它的类的外部访问</p>
<pre><code class="language-typescript">class Fn1 {
    private name: string
    public constructor(name: string, age: number) {
        this.name = name
    }
}
new Fn1().name // error 'name'是私有的
</code></pre>
<h3 id="protected">protected</h3>
<p>protected修饰符与 private修饰符的行为很相似，但有一点不同， protected成员在派生类中仍然可以访问</p>
<pre><code class="language-typescript">class Fn1 {
    protected name: string
    constructor(name: string, age: number) {
        this.name = name
    }
}
class Fn2 extends Fn1{
    constructor(name: string) {
       super(name)
    }
    public getName() {
        console.log(this.name)
    }
}
new Fn2('mickey').name // error 
new Fn2('mickey').getName() // mickey
</code></pre>
<p><strong>我们不能在Fn1类外使用name，但是我们可以在派生出来的实例方法上使用name</strong></p>
<h3 id="readonly修饰符">readonly修饰符</h3>
<p>你可以使用 readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化</p>
<pre><code class="language-typescript">class Fn1 {
    readonly name: string
    constructor(name: string) {
        this.name = name
    }
}
let f = new Fn2('mickey')
f.name = 'xxx' // error name是只读
</code></pre>
<h3 id="参数属性">参数属性</h3>
<pre><code class="language-typescript">class Fn1 {
    constructor(private name: string) { }
    getName(): string {
        console.log(this.name)
        return this.name
    }
}
</code></pre>
<p>上面代码我们通过在<code>constructor</code>参数<code>private name: string</code>来进行创建和初始化,我们就声明和赋值合并在一起了，public和 protected的使用也是一样</p>
<h3 id="存取器">存取器</h3>
<p>TypeScript支持通过getters/setters来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问</p>
<pre><code class="language-typescript">let passcode = &quot;secret passcode&quot;;

class Employee {
    private _fullName: string;

    get fullName(): string {
        return this._fullName;
    }

    set fullName(newName: string) {
        if (passcode &amp;&amp; passcode == &quot;secret passcode&quot;) {
            this._fullName = newName;
        }
        else {
            console.log(&quot;Error: Unauthorized update of employee!&quot;);
        }
    }
}

let employee = new Employee();
employee.fullName = &quot;Bob Smith&quot;;
if (employee.fullName) {
    alert(employee.fullName);
}
</code></pre>
<p>存取器要求你将编译器设置为输出ECMAScript 5或更高。 不支持降级到ECMAScript 3。 其次，只带有<code>get</code>不带有<code>set</code>的存取器自动被推断为 readonly。 这在从代码生成 .d.ts文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值</p>
<h3 id="static修饰符">static修饰符</h3>
<p>我们可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上</p>
<pre><code class="language-typescript">class Styles {
    static width = 200
    constructor(public style: object) {}
    getWidth() {
        console.log(Styles.width) // 200
    }
}
new Styles({height: 200})
</code></pre>
<h3 id="抽象类">抽象类</h3>
<p>抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。 abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法</p>
<pre><code class="language-typescript">abstract class Department {

    constructor(public name: string) {
    }

    printName(): void {
        console.log('Department name: ' + this.name);
    }

    abstract printMeeting(): void; // 必须在派生类中实现
}

class AccountingDepartment extends Department {

    constructor() {
        super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super()
    }

    printMeeting(): void {
        console.log('The Accounting Department meets each Monday at 10am.');
    }

    generateReports(): void {
        console.log('Generating accounting reports...');
    }
}

let department: Department; // 允许创建一个对抽象类型的引用
department = new Department(); // 错误: 不能创建一个抽象类的实例
department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值
department.printName();
department.printMeeting();
department.generateReports(); // 错误: 方法在声明的抽象类中不存在
</code></pre>
<p>上面我们介绍了<code>TypeScript</code>的类，第五节我们将介绍函数</p>
<blockquote>
<p>文章参考<a href="https://www.tslang.cn/docs/handbook/variable-declarations.html">TypeScript中文网</a><br>
<a href="http://es6.ruanyifeng.com/#docs/class">阮一峰Es6</a></p>
</blockquote>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#%E7%B1%BB">类</a></li>
<li><a href="#%E7%BB%A7%E6%89%BF">继承</a></li>
<li><a href="#public%E4%BF%AE%E9%A5%B0%E7%AC%A6">public修饰符</a></li>
<li><a href="#private%E4%BF%AE%E9%A5%B0%E7%AC%A6">private修饰符</a></li>
<li><a href="#protected">protected</a></li>
<li><a href="#readonly%E4%BF%AE%E9%A5%B0%E7%AC%A6">readonly修饰符</a></li>
<li><a href="#%E5%8F%82%E6%95%B0%E5%B1%9E%E6%80%A7">参数属性</a></li>
<li><a href="#%E5%AD%98%E5%8F%96%E5%99%A8">存取器</a></li>
<li><a href="#static%E4%BF%AE%E9%A5%B0%E7%AC%A6">static修饰符</a></li>
<li><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB">抽象类</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://xiaoai7904.github.io//post/typescript-ru-men-jiao-cheng-san-jie-kou">
              <h3 class="post-title">
                TypeScript入门教程(三) - 接口
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://xiaoai7904.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()

  let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

  // This should probably be throttled.
  // Especially because it triggers during smooth scrolling.
  // https://lodash.com/docs/4.17.10#throttle
  // You could do like...
  // window.addEventListener("scroll", () => {
  //    _.throttle(doThatStuff, 100);
  // });
  // Only not doing it here to keep this Pen dependency-free.

  window.addEventListener("scroll", event => {
    let fromTop = window.scrollY;

    mainNavLinks.forEach((link, index) => {
      let section = document.getElementById(decodeURI(link.hash).substring(1));
      let nextSection = null
      if (mainNavLinks[index + 1]) {
        nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
      }
      if (section.offsetTop <= fromTop) {
        if (nextSection) {
          if (nextSection.offsetTop > fromTop) {
            link.classList.add("current");
          } else {
            link.classList.remove("current");    
          }
        } else {
          link.classList.add("current");
        }
      } else {
        link.classList.remove("current");
      }
    });
  });

</script>

      </div>
    </div>
  </body>
</html>
