<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>js原型继承五条基本原 | xiaoai</title>
<meta name="description" content="记录美好生活" />
<link rel="shortcut icon" href="https://xiaoai7904.github.io//favicon.ico?v=1596959212487">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://xiaoai7904.github.io//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://xiaoai7904.github.io/">
  <img class="avatar" src="https://xiaoai7904.github.io//images/avatar.png?v=1596959212487" alt="">
  </a>
  <h1 class="site-title">
    xiaoai
  </h1>
  <p class="site-description">
    记录美好生活
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              js原型继承五条基本原
            </h2>
            <div class="post-info">
              <span>
                2019-11-24
              </span>
              <span>
                7 min read
              </span>
              
                <a href="https://xiaoai7904.github.io/tag/4kuYU9V7d/" class="post-tag">
                  # JavaScript
                </a>
              
            </div>
            
              <img class="post-feature-image" src="https://xiaoai7904.github.io//post-images/js-yuan-xing-ji-cheng-wu-tiao-ji-ben-yuan.png" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>js中的原型继承，遵守5个基本原则：</p>
<ul>
<li>所有的数据都是对象</li>
<li>要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它</li>
<li>对象会记住它的原型</li>
<li>如果对象无法响应某个请求，它会把这个请求委托给它自己的原型</li>
</ul>
<p>接下来我们将详细讲解这个5个基本原则.....</p>
<!--more-->
<h3 id="所有的数据都是对象">所有的数据都是对象</h3>
<p>js在设计的时候引入了java两套类型机制：<strong>基本类型</strong>和<strong>引用类型</strong></p>
<p>基本类型包括：<code>undefined、number、boolean、string、function、object</code></p>
<p>我们不能说js中所有的数据都是对象，但是可以说绝大多数的数据都是对象，那么相信在js中也一定会存在一个根对象(<strong>Object.prototype</strong>)</p>
<p>在js中根对象(<strong>Object.prototype</strong>)是一个空的对象，我们遇到的每一个对象都是从<strong>Object.prototype</strong>对象克隆而来，<strong>Object.prototype</strong>对象就是它们的原型。</p>
<pre><code class="language-javascript">    var obj_1 = new Object();
    var obj_2 = {};
    
    //通过Object.getPrototypeOf来查看它们的原型
    console.log(Object.getPrototypeOf(obj_1) === Object.prototype); // true
    console.log(Object.getPrototypeOf(obj_2) === Object.prototype); // true    
</code></pre>
<h3 id="要得到一个对象不是通过实例化类而是找到一个对象作为原型并克隆它">要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它</h3>
<p>在js中我们并不需要关心克隆的细节，因为这些操作浏览器引擎内部已经实现了，我们只需要显式地调用<code>var obj = new Object()或者var obj = {}</code>，引擎会从<code>Object.prototype</code>上克隆一个对象出来。</p>
<p>我们也可以通过new操作符来创建一个对象</p>
<pre><code class="language-javascript">    function Person(name){
        this.name= name;
    };
    
    Person.prototype.getName = function(){
        return this.name;
    }
    
    var r = new Person('anjie'); // 通过new操作符得到一个对象
    
    console.log(r.name);//anjie
    console.log(r.getName());//anjie
    console.log(Object.getPrototypeOf(r) === Person.prototype); // true
</code></pre>
<p><strong>我们通过new得到的对象具体做了什么？</strong><br>
要创建 Person 的新实例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下 4<br>
个步骤：</p>
<ol>
<li>创建一个新对象；</li>
<li>将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；</li>
<li>执行构造函数中的代码（为这个新对象添加属性；</li>
<li>返回新对象；</li>
</ol>
<p>new操作符具体做了3件事</p>
<pre><code class="language-javascript">    // 创建空对象
    var r = {}; 
    //将这个空对象的__proto__成员指向了Person函数对象prototype成员对象
    r.__proto__ = Person.prototype  
    //将Person函数对象的this指针替换成r，然后再调用Person函数,给r添加属性和方法
    Person.call(r)
</code></pre>
<p><strong>模仿new操作符</strong></p>
<pre><code class="language-javascript">    function Person(name){
        this.name = name;
    }
    
    Person.prototype.getName = function(){
        return this.name;
    }
    
    var simulationNew = function(){
        var obj = new Object(); // 从Objecet.prototype克隆一个对象
        var Constructor = [].shift.call(arguments); // 获取外部参数
        obj.__proto__ = Constructor.prototype;//指向正确的原型
        var newObj = Constructor.apply(obj,arguments); //借用外部传入的构造器给obj设置属性
        return typeof newObj === 'object' ? newObj : obj; //确保返回的永远是一个对象
    }
    
    var a = simulationNew(Person,'anjie');
    
    console.log(a.name);//anjie
    console.log(a.getName());//anjie
    console.log(Object.getPrototypeOf(a) === Person.prototype); // true
</code></pre>
<h3 id="对象会记住它的原型">对象会记住它的原型</h3>
<p>js给对象提供了一个名为<code>__proto__</code>的隐藏属性，某个对象的<code>__proto__</code>属性默认会指向它的构造器的原型对象，即<code>{Constructor.prototype}</code>,在一些浏览器中，<code>__proto__</code>被公开出来了(Chrome/Firefox)</p>
<pre><code class="language-javascript">    var a = new Object();
    console.log(a.__proto__ === Object.prototype); //true
</code></pre>
<p><code>__proto__</code>就是对象跟对象构造器的原型联系起来的桥梁，正因为对象通过<code>__proto__</code>来记住的构造器的原型，我们上面模拟new操作符需要手动的给obj对象设置正确的<code>__proto__</code>指向</p>
<h3 id="如果对象无法响应某个请求它会把这个请求委托给它自己的原型">如果对象无法响应某个请求，它会把这个请求委托给它自己的原型</h3>
<p>在js中，每个对象都是通过<code>Object.prototype</code>克隆出来的，如果是这样的话我们只能得到单一的继承关系，即每个对象都是继承自<code>Object.prototype</code>对象，这样的对象显然是非常受限的。</p>
<p>js对象最初都是由<code>Object.prototype</code>克隆而来，但是对象构造器的原型并不仅限于<code>Object.prototype</code>上，而是可以动态指向其他对象，这样一来，但对象a需要借用b对象的能力时，可以选择性的把对象a的原型指向对象b，从而达到继承的效果。</p>
<p><strong>下面的代码是我们常用的原型继承方式：</strong></p>
<pre><code class="language-javascript">    var obj = {name:'anjie'};
    
    var A = function(){}
    
    A.prototype = obj;
    
    var a = new A();
    
    console.log(a.name);//anjie
</code></pre>
<p><strong>上面的代码引擎内部做了什么？</strong></p>
<ul>
<li>遍历对象a中的所有属性，但是没有name这个属性</li>
<li>查找name属性的这个请求委托对象a的构造器的原型，它被<code>a.__proto__</code>记录着并且指向<code>A.prototype</code>,而<code>A.prototype</code>被设置为对象obj</li>
<li>在对象obj中找到name属性，并返回它的值</li>
</ul>
<p><strong>当我们期望得到一个类继承自另一个类时</strong>我们通常会使用下面这段代码：</p>
<pre><code class="language-javascript">    var A = function(){};
    A.prototype = {
        name:'anjie'
    }
    
    var B = function(){}
    B.prototype = new A();
    
    var b = new B();
    console.log(b.name);//anjie
</code></pre>
<p><strong>上面的代码引擎内部做了什么？</strong></p>
<ul>
<li>遍历对象a中的所有属性，但是没有name这个属性</li>
<li>查找name属性的这个请求委托对象b的构造器的原型，它被<code>b.__proto__</code>记录着并且指向<code>B.prototype</code>,而<code>B.prototype</code>被设置为通过<code>new A()</code>创建出来的对象</li>
<li>在该对象中依然没有找到name属性，于是请求将继续委托给这个对象构造器的原型<code>A.prototype</code></li>
<li>在<code>A.prototype</code>中找到name属性，并返回它的值</li>
</ul>
<p>如果<code>A.prototype</code>中还没有知道name属性，请求会被传递给<code>A.prototype</code>的原型<code>Object.prototype</code>，如果没有name属性，会继续传递给<code>Object.prototype</code>的原型，<code>Object.prototype</code>的原型是<code>null</code>,所以会返回<code>undefined</code></p>
<p>ES6的中带来了新的<code>Class</code>语法，让js看起来更加想一门基于类的语言，其实背后还是通过原型机制来实现的。</p>
<pre><code class="language-javascript">    Class Person{
        constructor(name){
            this.name = name;
        },
        getName(){
            return this.name
        }
    }
    
    Class manPerson extends Person {
        constructor(name){
            super(name);
        }
    }
    
    var a = new manPerson('anjie');
    console.log(a.getName());//anjie
</code></pre>
<p>总结就写到这里了，本文简单介绍了js中原型继承的机制，希望通过学习的我们的学习总结笔记让大家也有收获，如果有什么不对的地方，望大家指点出来，我们共同学习。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#%E6%89%80%E6%9C%89%E7%9A%84%E6%95%B0%E6%8D%AE%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1">所有的数据都是对象</a></li>
<li><a href="#%E8%A6%81%E5%BE%97%E5%88%B0%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E4%B8%8D%E6%98%AF%E9%80%9A%E8%BF%87%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%B1%BB%E8%80%8C%E6%98%AF%E6%89%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E5%8E%9F%E5%9E%8B%E5%B9%B6%E5%85%8B%E9%9A%86%E5%AE%83">要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它</a></li>
<li><a href="#%E5%AF%B9%E8%B1%A1%E4%BC%9A%E8%AE%B0%E4%BD%8F%E5%AE%83%E7%9A%84%E5%8E%9F%E5%9E%8B">对象会记住它的原型</a></li>
<li><a href="#%E5%A6%82%E6%9E%9C%E5%AF%B9%E8%B1%A1%E6%97%A0%E6%B3%95%E5%93%8D%E5%BA%94%E6%9F%90%E4%B8%AA%E8%AF%B7%E6%B1%82%E5%AE%83%E4%BC%9A%E6%8A%8A%E8%BF%99%E4%B8%AA%E8%AF%B7%E6%B1%82%E5%A7%94%E6%89%98%E7%BB%99%E5%AE%83%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8E%9F%E5%9E%8B">如果对象无法响应某个请求，它会把这个请求委托给它自己的原型</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://xiaoai7904.github.io/post/js-she-ji-mo-shi-dan-li-mo-shi/">
              <h3 class="post-title">
                js设计模式-单例模式
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '542a046d9cd2c40810d6',
    clientSecret: '3f40254747f30cec544eed0010a8671076c68908',
    repo: 'xiaoai7904.github.io',
    owner: 'xiaoai7904',
    admin: ['xiaoai7904'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://xiaoai7904.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()

  let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

  // This should probably be throttled.
  // Especially because it triggers during smooth scrolling.
  // https://lodash.com/docs/4.17.10#throttle
  // You could do like...
  // window.addEventListener("scroll", () => {
  //    _.throttle(doThatStuff, 100);
  // });
  // Only not doing it here to keep this Pen dependency-free.

  window.addEventListener("scroll", event => {
    let fromTop = window.scrollY;

    mainNavLinks.forEach((link, index) => {
      let section = document.getElementById(decodeURI(link.hash).substring(1));
      let nextSection = null
      if (mainNavLinks[index + 1]) {
        nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
      }
      if (section.offsetTop <= fromTop) {
        if (nextSection) {
          if (nextSection.offsetTop > fromTop) {
            link.classList.add("current");
          } else {
            link.classList.remove("current");    
          }
        } else {
          link.classList.add("current");
        }
      } else {
        link.classList.remove("current");
      }
    });
  });

</script>

      </div>
    </div>
  </body>
</html>
